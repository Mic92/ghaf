<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ghaf Framework</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for TII SSRC Secure Technologies.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Ghaf Framework</li><li class="chapter-item expanded "><a href="architecture/architecture.html"><strong aria-hidden="true">1.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/adr.html"><strong aria-hidden="true">1.1.</strong> Decision Record</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/adr/minimal-host.html"><strong aria-hidden="true">1.1.1.</strong> Minimal host</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="technologies/technologies.html"><strong aria-hidden="true">2.</strong> Technologies</a></li><li class="chapter-item expanded "><a href="build_config/build_configurations.html"><strong aria-hidden="true">3.</strong> Build Configurations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="build_config/reference_implementations.html"><strong aria-hidden="true">3.1.</strong> Reference Implementations</a></li><li class="chapter-item expanded "><a href="build_config/cross_compilation.html"><strong aria-hidden="true">3.2.</strong> Cross Compilation</a></li></ol></li><li class="chapter-item expanded "><a href="scs/scs.html"><strong aria-hidden="true">4.</strong> Supply Chain Security</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scs/slsa-framework.html"><strong aria-hidden="true">4.1.</strong> SLSA Framework</a></li><li class="chapter-item expanded "><a href="scs/basics.html"><strong aria-hidden="true">4.2.</strong> Basic Security Measures</a></li><li class="chapter-item expanded "><a href="scs/sbom.html"><strong aria-hidden="true">4.3.</strong> SBOM</a></li><li class="chapter-item expanded "><a href="scs/pki.html"><strong aria-hidden="true">4.4.</strong> Public Key Infrastructure</a></li><li class="chapter-item expanded "><a href="scs/patching-automation.html"><strong aria-hidden="true">4.5.</strong> Patch Management Automation</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">References</li><li class="chapter-item expanded "><a href="research/research.html"><strong aria-hidden="true">5.</strong> Research Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="research/passthrough/ethernet.html"><strong aria-hidden="true">5.1.</strong> i.MX 8QM Ethernet Passthrough</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="appendices/glossary.html">Glossary</a></li><li class="chapter-item expanded affix "><a href="appendices/contributing_general.html">Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ghaf Framework</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tiiuae/ghaf" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tii-ssrc-secure-technologies-ghaf-framework"><a class="header" href="#tii-ssrc-secure-technologies-ghaf-framework">TII SSRC Secure Technologies: Ghaf Framework</a></h1>
<p>Secure Tech-project studies secure technologies in the context of embedded virtualization. This documentation-project, named after Ghaf tree, provides a landing site to our work. Our applied software research supports <a href="https://www.tii.ae/secure-systems">Secure Systems Research Center</a> focus areas.</p>
<h2 id="embedded-virtualization"><a class="header" href="#embedded-virtualization">Embedded Virtualization</a></h2>
<p>Embedded virtualization builds on cloud technologies in the development of end-to-end security. With hardware support for virtualization, we provide hardened system of small trusted computing base (TCB) - thin host - that enables isolation of use cases and their resources. Use cases are protected in guest virtual machines. Embedded targets small devices - personal or headless - instead of high performance cloud servers. Our scope is illustrated in the following diagram.</p>
<p><img src="img/overview.png" alt="Scope!" title="Embedded Virtualization Scope" /></p>
<h2 id="reference-implementation"><a class="header" href="#reference-implementation">Reference Implementation</a></h2>
<p>Ghaf is developing a reference implementation for NVIDIA Jetson devices. See <a href="https://github.com/tiiuae/ghaf/#build-instructions">build instructions</a> for more info.
Legacy reference implementation for NXP i.MX8 <a href="https://github.com/tiiuae/spectrum-config-imx8">is available here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The main architectural concept of the Ghaf platform is to break up the traditional monolithic structure to modularized components, virtual machines (VM). These VMs on hardened host OS implement the Ghaf edge virtualization platform. The Ghaf platform components are used in reference configurations to build images for reference devices. See <a href="architecture/../build_config/build_configurations.html">build configurations</a> and <a href="architecture/../build_config/reference_implementations.html">reference implementations</a> for more info.</p>
<p>See <a href="architecture/adr.html">architectural decisions record</a> for more info on design choices that address architectural requirements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-decision-records"><a class="header" href="#architecture-decision-records">Architecture Decision Records</a></h1>
<p><a href="https://adr.github.io">Architecture decision records (ADR)</a> are used to constitute the Ghaf platform decision log.</p>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Contributions to Ghaf architecture decisions are welcome. Please create an architectural decision proposal by opening <a href="https://github.com/tiiuae/ghaf/pulls">a pull request</a> using the <a href="https://github.com/tiiuae/ghaf/blob/main/docs/src/architecture/adr/template.md">template</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimal-host"><a class="header" href="#minimal-host">Minimal Host</a></h1>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>Proposed</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>Ghaf uses the default NixOS configuration as a baseline to build the target image.</p>
<p>The default NixOS configuration is targeted for more general use with the inclusion of
multiple packages that are not supporting the Ghaf design target of a minimal trusted
computing base (TCB) to protect the host.</p>
<p>This structure in the Ghaf host configuration imports the NixOS minimal profile
which suits the minimal TCB better. Even better, the modular declarative profile enables
the further optimization of the minimal TCB while supporting other profiles that suit
evaluation of other objectives such as feasibility studies of additional functionality,
security and performance.</p>
<h2 id="decision"><a class="header" href="#decision">Decision</a></h2>
<p>This change adopts a minimal profile from NixOS. It reduces both image and root partition
size by eliminating the host OS content as defined in the NixOS minimal profile.</p>
<p>The proposed profile from NixOS can be <a href="https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/profiles/minimal.nix">reviewed here</a>.</p>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<p>Additional host dependencies must be declared explicitly to get included on the host.</p>
<p>Some functionality assumed with the default host may break or may not be available as
the earlier baseline functionality with graphics and other functionality has not yet
been implemented. In practice, the host will not have graphical libraries by default, and
such functionality would need to be either imported using another profile or passed
through to a guest VM that supports modular design by separating the graphics architecture
from the host. The same applies to other guest VMs that implement other system functionality.</p>
<p>Further development of the host security, such as hardening, becomes easier as such
profiles can be tested in isolation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="technologies"><a class="header" href="#technologies">Technologies</a></h1>
<p>Embedded virtualization builds on technologies from cloud security. Cloud services provide scalable but isolated computation — your business case is isolated from someone else's business case.</p>
<p>At the hardware level. Similarly, hardware support in modern personal devices has enabled the isolation of device resources with virtualization. This provides the baseline for secure system design for use case protection.</p>
<p>In practice, the user can use the same device with a trusted application and with an untrusted application. Both applications are isolated from each other to protect valuable user data and privacy. Our systems are built using <a href="https://github.com/NixOS/nixpkgs">nixpkgs</a> and various <a href="https://nixos.org/guides/nix-language.html">Nix</a> based tools and configurations.</p>
<h2 id="hardware-requirements-for-virtualization"><a class="header" href="#hardware-requirements-for-virtualization">Hardware Requirements for Virtualization</a></h2>
<p>Protected computation resources include CPU, memory, storage, and other IO devices. Allocation of these resources is managed with the hypervisor.</p>
<p>In our reference implementation, we use KVM (Kernel Virtual Machine) from Linux to virtualize hardware access. From hardware, this requires MMU (memory management unit) for CPU physical to virtual address mapping and IOMMU for direct memory access (DMA) capable device virtual addresses to physical addresses of the main memory. Many 64-bit CPUs support virtualization via hypervisor extensions already. Our reference implementation supports x86-64 and Aarch64, and we follow RISC-V hypervisor extensions development.</p>
<p>Our current reference hardware is <a href="https://github.com/tiiuae/spectrum-config-imx8">NXP iMX8 QM development board</a>. In addition, x86-64 hardware is supported via Spectrum OS upstream.</p>
<h2 id="virtual-machine-manager-vmm"><a class="header" href="#virtual-machine-manager-vmm">Virtual Machine Manager (VMM)</a></h2>
<p>On top of OS kernel hypervisor support with KVM. We allocate virtual resources for use cases with user-space virtual machine manager (VMM) using <a href="https://github.com/rust-vmm">rust-vmm</a> based projects such as <a href="https://github.com/cloud-hypervisor/cloud-hypervisor">cloud-hypervisor</a> and <a href="https://github.com/google/crosvm">crosvm</a>. <a href="https://www.qemu.org/">QEMU</a> is enabled for certain development use cases.</p>
<p>In addition, we have also experimental, Aarch64 demonstrated support for a KVM variant — <a href="https://github.com/jkrh/kvms">KVMS</a> — which adds security features to standard KVM.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-configurations"><a class="header" href="#build-configurations">Build Configurations</a></h1>
<p>Our hardened operating system (OS) targets are build configurations based on NixOS. The canonical URL for the upstream git repository is: <a href="https://github.com/NixOS">https://github.com/NixOS</a>.</p>
<p>Build configurations define our dependencies and configuration changes to packages and build mechanisms of NixOS. If you want to try, see the <a href="build_config/../build_config/reference_implementations.html">reference implementations</a>.</p>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>A build configuration is a target to build our hardened OS for a particular hardware device. Most packages used in a build configuration come from <a href="https://github.com/NixOS/nixpkgs">nixpkgs - NixOS Packages collection</a>.</p>
<p>The upstream first approach means we aim the fix issues by contributing to nixpkgs. At the same time, we get the maintenance support of NixOS community and the benefits of the Nix language on how to build packages and track the origins of packages in the software supply chain security. For more information, see <a href="build_config/../scs/scs.html">Supply Chain Security</a>.</p>
<p>NixOS, a Linux OS distribution packaged with Nix, provides us with:</p>
<ul>
<li>generic hardware architecture support (<code>x86-64</code> and <code>AArch64</code>);</li>
<li>declarative and modular mechanism to describe the system;</li>
<li>Nix packaging language mechanisms:
<ul>
<li>to extend and change packages with <a href="https://nixos.wiki/wiki/Overlays">overlays</a>,</li>
<li>to <a href="https://nixos.org/guides/nix-pills/override-design-pattern.html">override</a> packages.</li>
</ul>
</li>
</ul>
<p>Even when unmodified upstream is often preferred, even ideal, to ensure timely security updates from upstream — customizations are sometimes required.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>To support a reference board without a vendor board support package (BSP) — bootloader, kernel, device drivers — is often not feasible. With this approach, we can overlay the generic NixOS Linux kernel with the vendor kernel and add a vendor bootloader to build a target image.</p>
<p>Often the vendor BSPs are also open source but sometimes contain unfree binary blobs from the vendor's hardware. Those are handled by allowing <code>unfree</code> - if the user agrees with the end-user license agreement (EULA). If not, <code>unfree</code> support can be dropped along with that part of the BSP support.</p>
<p>The same goes with the architectural variants as headless devices or end-user devices differ in terms what kind of virtual machines (VM) they contain. The user needs graphics architecture and VM support for the user interface (UI) whereas a headless device is more like a small server without the UI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-implementations"><a class="header" href="#reference-implementations">Reference Implementations</a></h1>
<h2 id="supported-targets"><a class="header" href="#supported-targets">Supported Targets</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Hardware</th><th>Architecture</th><th>Scope</th></tr></thead><tbody>
<tr><td>Generic Intel</td><td>x86</td><td>QEMU</td></tr>
<tr><td>NVIDIA Orin AGX</td><td>aarch64</td><td>hardware</td></tr>
</tbody></table>
</div>
<p>Scope of target support is updated with development progress.</p>
<h2 id="build-instructions"><a class="header" href="#build-instructions">Build Instructions</a></h2>
<p>Ghaf uses a Nix flake approach to build the framework targets.</p>
<p>See <a href="https://nixos.org/download.html">Nix installation instructions</a> for further details.
Make also sure to <a href="https://nixos.wiki/wiki/Flakes#Enable_flakes">enable flakes</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Hardware</th><th>architecture</th><th>scope</th><th>build command</th></tr></thead><tbody>
<tr><td>Generic Intel</td><td>x86</td><td>VM</td><td><code>nix build .#packages.x86_64-linux.vm</code></td></tr>
<tr><td>NVIDIA Orin AGX</td><td>aarch64</td><td>HW</td><td><code>nix build .#packages.aarch64-linux.nvidia-jetson-orin</code></td></tr>
</tbody></table>
</div>
<p>To see all Ghaf supported outputs, type <code>nix flake show</code>.</p>
<h2 id="run-instructions"><a class="header" href="#run-instructions">Run Instructions</a></h2>
<p>The development username and password are defined in <a href="https://github.com/tiiuae/ghaf/blob/main/modules/development/authentication.nix#L4-L5">authentication module</a>.</p>
<h3 id="virtual-machine---ghaf-host"><a class="header" href="#virtual-machine---ghaf-host">Virtual Machine - ghaf-host</a></h3>
<p><code>nix run .#packages.x86_64-linux.vm</code></p>
<blockquote>
<p><strong>NOTE:</strong> this creates <code>ghaf-host.qcow2</code> copy-on-write overlay disk image in your current directory. If you do unclean shutdown for the QEMU VM, you might get weird errors the next time you boot. Simply removing <code>ghaf-host.qcow2</code> should be enough. To cleanly shut down the VM, from the menu bar of the QEMU Window, click Machine and then click Power Down.</p>
</blockquote>
<h3 id="nvidia-jetson-orin-agx"><a class="header" href="#nvidia-jetson-orin-agx">NVIDIA Jetson Orin AGX</a></h3>
<ul>
<li>Prequisite (firmware version): <a href="https://github.com/mikatammi/jetpack-nixos/tree/flash_orin_hack#hack-for-flashing-nvidia-jetson-orin">Update the NVIDIA Jetson Orin AGX UEFI firmware to version r35.1 to boot from USB</a></li>
<li>Prequisite (cross-compilation support): <code>binfmt</code> and NixOS is required.
<ul>
<li>Enable <code>binfmt</code> in your <code>configuration.nix</code> with:
<pre><code>boot.binfmt.emulatedSystems = [
  &quot;aarch64-linux&quot;
];
</code></pre>
</li>
<li>For more details, see <a href="https://tiiuae.github.io/ghaf/build_config/cross_compilation.html">Cross Compilation</a>.</li>
</ul>
</li>
<li>Prepare the USB boot media with the target HW image you built:
<ul>
<li><code>dd if=./result/nixos.img of=/dev/&lt;YOUR_USB_DRIVE&gt; bs=32M</code></li>
</ul>
</li>
<li>Boot the hardware from USB media</li>
</ul>
<h2 id="development-tips"><a class="header" href="#development-tips">Development Tips</a></h2>
<p>If you set up development SSH keys into <a href="https://github.com/tiiuae/ghaf/blob/main/modules/development/ssh.nix#L4">SSH module</a>, you can use <code>nixos-rebuild switch</code> to quickly deploy your configuration changes to the development board over the network using SSH:</p>
<pre><code>nixos-rebuild --flake .#nvidia-jetson-orin --target-host root@orin-hostname --fast switch
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-compilation"><a class="header" href="#cross-compilation">Cross Compilation</a></h1>
<p>Ghaf is targeted at a range of devices and form factors that support different Instruction Set Architectures (ISA). Many small form-factor edge devices are not powerful enough to compile the needed applications or operating systems that run on them. As the most common ISA used in desktops and servers is <code>x\_86</code>, this will generally require that the code is cross-compiled for target ISA e.g. <code>AArch64</code> or <code>RISC-V</code>.</p>
<p>NixOS and Nixpkgs have good support for cross-compilation, however, there are still some that can not be compiled in this way.</p>
<h2 id="binfmt"><a class="header" href="#binfmt">Binfmt</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Binfmt_misc">binfmt</a> allows running different ISA on a development machine. This is achieved by running the target binary in an emulator such as <code>QEMU</code> or in a virtual machine.</p>
<p>To enable binfmt, it is advisable to set the following in your host systems <code>configuration.nix</code>:</p>
<pre><code>boot.binfmt.emulatedSystems = [
  &quot;riscv64-linux&quot;
  &quot;aarch64-linux&quot;
];
</code></pre>
<p>In addition it is recommended to enable KVM support with either:</p>
<pre><code>boot.kernelModules = [ &quot;kvm-amd&quot; ];
</code></pre>
<p>or</p>
<pre><code>boot.kernelModules = [ &quot;kvm-intel&quot; ];
</code></pre>
<p>depending on whether your development host is running <code>AMD</code> or <code>Intel</code> version of <code>x\_86</code>.</p>
<h2 id="future-cross-compilation-support"><a class="header" href="#future-cross-compilation-support">Future Cross Compilation Support</a></h2>
<p>This will involve working with upstream package maintainers to ensure that the packages are cross compilation aware. This will be addressed on a package-by-package basis.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supply-chain-security"><a class="header" href="#supply-chain-security">Supply Chain Security</a></h1>
<p>To be aware of what is exactly in our software supply chain, it is reviewed for security issues and known vulnerabilities.</p>
<p><img src="scs/../img/threat_processing.drawio.png" alt="Supply Chain Attacks Diagram" title="Supply Chain Attacks" /></p>
<p>We implement a <em>supply chain security (SCS)</em> — process of securing the machinery of the development, building, and release environment. That means that every component that a software artifact might be touching on its way from the developer to the consumer will be secured.</p>
<p>The software artifact should be encrypted on each possible transition phase and its integrity should be verified at each destination. Each build should be accompanied by means of <a href="https://fossa.com/blog/software-bill-of-materials-formats-use-cases-tools/"><em>software bill of materials (SBOM)</em></a>, identifying all the components that the software package consists of.</p>
<p>SBOM containing reference to each dependency, its source and version together with provenance, containing build information are collected at the build time, signed, and used for vulnerability analysis during the next steps.</p>
<p>The software artifact, SBOM, and provenance are signed by the build machinery at the build time, and the signature is verifiable at every destination of the package. The certificates that are used for signing and verification are provided by the <em>public key infrastructure (PKI)</em> system and are signed by the same root <em>certificate authority (CA)</em>. That allows you to confirm the author of the signature (build machinery) and guarantees that the package has not been tampered with since the build time.</p>
<h2 id="in-this-chapter"><a class="header" href="#in-this-chapter">In This Chapter</a></h2>
<ul>
<li><a href="scs/../scs/slsa-framework.html">SLSA Framework</a></li>
<li><a href="scs/../scs/basics.html">Basic Security Measures</a></li>
<li><a href="scs/../scs/sbom.html">SBOM</a></li>
<li><a href="scs/../scs/pki.html">Public Key Infrastructure</a></li>
<li><a href="scs/../scs/patching-automation.html">Patch Management Automation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slsa-framework"><a class="header" href="#slsa-framework">SLSA Framework</a></h1>
<p>Supply chain Levels for Software Artifacts (SLSA) is a security framework for tampering prevention, integrity improvement, and securing packages and infrastructure of a project. For more information about the SLSA framework, see the offical website <a href="https://slsa.dev">https://slsa.dev</a>.</p>
<h2 id="slsa-terminology"><a class="header" href="#slsa-terminology">SLSA Terminology</a></h2>
<p><strong>Immutable reference:</strong> An identifier, guaranteed to always point to the same, immutable artifact.</p>
<p><strong>Provenance:</strong> Metadata about how an artifact was produced.</p>
<p><strong>Revision:</strong> An immutable, coherent state of a source.</p>
<h2 id="levels-of-assurance"><a class="header" href="#levels-of-assurance">Levels of Assurance</a></h2>
<p>One of the requirements for the solution is to reach SLSA Level 4 and even go beyond that. This requires a lot of process changes as well as technical work. </p>
<p>The SLSA model consists of 4 levels, offering an incremental level of anti-tampering protection. Levels 1-3 represent milestones with certain integrity guarantees, whereas level 4 is an ideal end state.</p>
<p><strong>Level 0</strong> means no SLSA compliance and no guarantees are given.</p>
<p><strong>Level 1</strong> demands a fully scripted / automated build process and provenance generation. It offers basic confidence in the origin of the software but doesn’t provide any tamper resistance.</p>
<p><strong>Level 2</strong> Introduces authenticated provenance generated by a hosted build at the same time demanding version control system usage. Provenance prevents tampering and offers trust in the build service.</p>
<p><strong>Level 3</strong> offers auditability of the source and the integrity of the provenance. Much stronger tampering protection is provided by preventing specific classes of threats such as cross-build contamination.</p>
<p><strong>Level 4</strong> requires two-peer source code review and a hermetic, reproducible build process. Overall Level 4 offers a high degree of confidence in the anti-tampering protection of the software.</p>
<p>SLSA level is not transitive, thus level of the artifact is not dependent on the level of dependencies, which are expected to have their own SLSA levels. This makes it possible to build a Level 4 artifact from Level 0 dependencies. </p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Requirements</th><th>Level 1</th><th>Level 2</th><th>Level 3</th><th>Level 4</th></tr></thead><tbody>
<tr><td>Source — <a href="https://slsa.dev/spec/v0.1/requirements#version-controlled">Version controlled</a></td><td></td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Source — <a href="https://slsa.dev/spec/v0.1/requirements#verified-history">Verified history</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Source — <a href="https://slsa.dev/spec/v0.1/requirements#retained-indefinitely">Retained indefinitely</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Source — <a href="https://slsa.dev/spec/v0.1/requirements#two-person-reviewed">Two-person reviewed</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#scripted-build">Scripted build</a></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#build-service">Build service</a></td><td></td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#build-as-code">Build as code</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#ephemeral-environment">Ephemeral environment</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#isolated">Isolated</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#parameterless">Parameterless</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#hermetic">Hermetic</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#reproducible">Reproducible</a></td><td></td><td></td><td></td><td>○</td></tr>
<tr><td>Provenance — <a href="https://slsa.dev/spec/v0.1/requirements#available">Available</a></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Provenance — <a href="https://slsa.dev/spec/v0.1/requirements#authenticated">Authenticated</a></td><td></td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Provenance — <a href="https://slsa.dev/spec/v0.1/requirements#service-generated">Service generated</a></td><td></td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Provenance — <a href="https://slsa.dev/spec/v0.1/requirements#non-falsifiable">Non-falsifiable</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Provenance — <a href="https://slsa.dev/spec/v0.1/requirements#dependencies-complete">Dependencies complete</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Common — <a href="https://slsa.dev/spec/v0.1/requirements#security">Security</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Common — <a href="https://slsa.dev/spec/v0.1/requirements#access">Access</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Common — <a href="https://slsa.dev/spec/v0.1/requirements#superusers">Superusers</a></td><td></td><td></td><td></td><td>✓</td></tr>
</tbody></table>
</div>
<p>✓ — required</p>
<p>○ — required unless justified otherwise</p>
<p>empty cell — not required</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-security-measures"><a class="header" href="#basic-security-measures">Basic Security Measures</a></h1>
<h2 id="source-code--version-control-security"><a class="header" href="#source-code--version-control-security">Source Code / Version Control Security</a></h2>
<p>The source code security is based on the fact that the source code is two-person reviewed, version controlled, and the history is verified and retained indefinitely.</p>
<h3 id="commit-signing"><a class="header" href="#commit-signing">Commit Signing</a></h3>
<p>All the commits to repositories must be GPG-signed. This can be achieved by enabling GPG commit signatures in the config:</p>
<p><code>git config --global commit.gpgsign true</code></p>
<p>For more detailed information, see the <a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits" title="Signing Commits on GitHub">Signing commits</a> article of the GitHub Docs.</p>
<h3 id="branch-protection"><a class="header" href="#branch-protection">Branch Protection</a></h3>
<p>In the case of GitHub the following settings should be considered:</p>
<ul>
<li>Require pull request reviews before merging (req: two-person reviewed source).</li>
<li>Require status checks before merging.</li>
<li>Require conversation resolution before merging.</li>
<li>Require signed commits.</li>
<li>Deletions should be forbidden (req: immutable history).</li>
</ul>
<h2 id="software-signing"><a class="header" href="#software-signing">Software Signing</a></h2>
<p>Software signing is an important measure to validate the author and ensure that the code has not been altered on the way from the developer to the customer. Nix tooling is offering means to sign the derivations using libsodium with EdDSA, however, as the modular system is assumed, scripts need to be developed to support signing mechanisms in an absence of Nix tooling.</p>
<p>By default, the software image is signed only at the binary cache per request. Which leaves the path from Hydra to the binary cache unsecured. The problem can be resolved in two ways:</p>
<ul>
<li>Enabling the image signing on Hydra</li>
<li>Shared Nix Store</li>
</ul>
<h3 id="enabling-image-signing-on-hydra"><a class="header" href="#enabling-image-signing-on-hydra">Enabling Image Signing on Hydra</a></h3>
<p>Enabling the image signing on Hydra requires some extra work due to the lack of well-documented support of image signing at Hydra at the time of writing this document. As already mentioned, NixOS is using libsodium-based EdDSA solution for image signing. So similar scripts can be implemented. For example, in Python by using existing libsodium bindings, such as PyNaCl.</p>
<p><img src="scs/../img/threat_processing_2serv.drawio.png" alt="Enabling Image Signing on Hydra" title="Enabling The Image Signing On Hydra" /></p>
<h3 id="shared-nix-store"><a class="header" href="#shared-nix-store">Shared Nix Store</a></h3>
<p>The shared NixStore option is rather straightforward if Hydra is combined with the binary cache. This kind of setup is lacking the extra transition path. Thus the packages signed by the binary cache will be served straight from the Hydra NixStore.</p>
<p><img src="scs/../img/threat_processing_1serv.drawio.png" alt="Shared NixStore Solution" title="Shared NixStore" /></p>
<h2 id="data-encryption-in-transit"><a class="header" href="#data-encryption-in-transit">Data Encryption in Transit</a></h2>
<p>All the data should be transported over secure encrypted channels. Since all the transportation is done over TCP/IP protocol stack, it is possible to use native solutions like TLS to secure the traffic between the nodes. Version 1.2 is a minimum requirement.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-bill-of-materials-sbom"><a class="header" href="#software-bill-of-materials-sbom">Software Bill of Materials (SBOM)</a></h1>
<p>Software bill of materials (SBOM) is a formal, machine-readable document that provides a list of software components that make up the target software and all its dependencies.</p>
<h2 id="sbom-formats-and-specifications"><a class="header" href="#sbom-formats-and-specifications">SBOM Formats and Specifications</a></h2>
<p>There are three main delivery formats and specifications for SBOM: CycloneDX, SPDX, and SWID.</p>
<p><a href="https://cyclonedx.org/specification/overview/">CycloneDX</a> is an open-source standard with origins in the <a href="https://en.wikipedia.org/wiki/OWASP">OWASP</a> community. The specification's original focus is on security. There's a large growing community and open source tooling that support CycloneDX format.</p>
<p><a href="https://spdx.dev/specifications/">SPDX</a> is also a product of an open-source community, with the original focus on licensing. SPDX is run and maintained by <a href="https://en.wikipedia.org/wiki/Linux_Foundation">Linux Foundation</a>. Similarly to CycloneDX, many open-source tools support the SPDX format. </p>
<p><a href="https://nvd.nist.gov/products/swid">SWID</a> is a <a href="https://www.iso.org/standard/65666.html">standard</a> that originates from <a href="https://www.nist.gov/">NIST</a>. SWID tags aim to help organizations create accurate software inventories. While SWID can serve as an SBOM too, it is not as widely used SBOM format in open source as the two other specifications.</p>
<h2 id="sbom-usage-in-ghaf"><a class="header" href="#sbom-usage-in-ghaf">SBOM Usage in Ghaf</a></h2>
<p>Ghaf framework will use SBOMs for:</p>
<ul>
<li>Vulnerability identification: automatic correlation of SBOM against known vulnerabilities.</li>
<li>Vulnerability remediation: automatic process to suggest fixes for identified vulnerabilities.</li>
<li>Dependency analysis: categorization of open-source and closed source software dependencies.</li>
<li>Dependency analysis: creation of a directed acyclic graph</li>
<li>License compliance: know and comply with the license obligations.</li>
<li>Market signal: publish SBOM together with other release artifacts.</li>
</ul>
<h2 id="sbom-tooling-in-ghaf"><a class="header" href="#sbom-tooling-in-ghaf">SBOM Tooling in Ghaf</a></h2>
<p>Ghaf is based on Nix, therefore, the selected SBOM tooling needs to support creating SBOMs for nix artifacts. As part of the Ghaf project, we have created the sbomnix tool to support SBOM generation for Ghaf and, more generally, for any nix targets. For more details on the SBOM tooling in Ghaf, see <a href="https://github.com/tiiuae/sbomnix#sbomnix">sbomnix</a> and <a href="https://github.com/tiiuae/sbomnix/blob/main/doc/nixgraph.md#nixgraph">nixgraph</a>.</p>
<p>Initially, sbomnix will support <a href="https://cyclonedx.org/specification/overview/">CycloneDX</a> SBOM specification, due to the availability of other open source tools that also support CycloneDX. Support for other SBOM formats to sbomnix might be added in later versions.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://ntia.gov/page/software-bill-materials">https://ntia.gov/page/software-bill-materials</a></li>
<li><a href="https://slsa.dev/blog/2022/05/slsa-sbom">https://slsa.dev/blog/2022/05/slsa-sbom</a></li>
<li><a href="https://fossa.com/blog/software-bill-of-materials-formats-use-cases-tools">https://fossa.com/blog/software-bill-of-materials-formats-use-cases-tools</a></li>
<li><a href="https://www.legitsecurity.com/blog/what-is-an-sbom-sbom-explained-in-5-minutes">https://www.legitsecurity.com/blog/what-is-an-sbom-sbom-explained-in-5-minutes</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-key-infrastructure"><a class="header" href="#public-key-infrastructure">Public Key Infrastructure</a></h1>
<p>In the SCS context, a public key infrastructure (PKI) term refers to a system for the creation, storage, and distribution of digital certificates which are used to verify that a particular key belongs to a certain entity. PKI creates and manages a hierarchical set of digital certificates which map public keys to certain entities. Storage and revocation methodologies are to be defined.</p>
<p>The PKI of SCS should consist of:</p>
<ul>
<li>Certificate authority (CA) for storing, issuing, and signing the digital certificates.</li>
<li>Registration authority (RA) for requesting entity identity verification.</li>
<li>Central directory for the secure storage of the keys.</li>
<li>Certificate Management System (CMS) for managing access to stored certificates.</li>
</ul>
<h2 id="private-certificate-authority-pca"><a class="header" href="#private-certificate-authority-pca">Private Certificate Authority (PCA)</a></h2>
<p>PCA enables the creation of private certificate authority hierarchies, consisting of Root and Subordinate CAs. It issues end-entity X.509 certificates, that are used for: </p>
<ul>
<li>Encrypted TLS communication channels (data encryption in transit)</li>
<li>Code and image signing</li>
</ul>
<p>PCA can be established in the cloud or on-premises. Initially, the OpenSSL-based solution deployed on-premises is assumed, however, some of the target projects might consider using commercial cloud solutions. </p>
<h2 id="hardware-security-module"><a class="header" href="#hardware-security-module">Hardware Security Module</a></h2>
<p>On-premises solution can be further improved by adding a Hardware Security Module (HSM). It is a physical device for managing cryptographic material such as digital keys. </p>
<p>HSM can be also used to perform cryptographic operations such as digital signing, encryption, and decryption. The HSM contains one or more Secure Cryptoprocessors that are dedicated microprocessors optimized for carrying out cryptographic operations. </p>
<p>One example of affordable HSM solutions is YubiHSM developed by Yubico.</p>
<h3 id="hsm-variants-for-consideration"><a class="header" href="#hsm-variants-for-consideration">HSM Variants for Consideration</a></h3>
<p>The following HSM Solutions are considered for the Ghaf project:</p>
<ul>
<li><a href="https://www.yubico.com/fi/product/yubihsm-2/" title="YubiHSM2">YubiHSM2</a></li>
<li><a href="https://shop.nitrokey.com/shop/product/nkhs2-nitrokey-hsm-2-7" title="NitrokeyHSM2">NitrokeyHSM2</a></li>
<li><a href="https://github.com/opendnssec/SoftHSMv2" title="SoftHSMv2">SoftHSMv2</a></li>
<li>BreadboardHSM</li>
</ul>
<p>The following table provides feature comparison of the proposed solutions. </p>
<blockquote>
<p>Since the feature list is quite extensive, the table is limited to the features that are either planned to be used in Ghaf or might benefit the project in the future.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>YubiHSM2</th><th>NitrokeyHSM2</th><th>SoftHSMv2</th><th>BreadboardHSM</th></tr></thead><tbody>
<tr><td>Secure key storage</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>ECC</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>EdDSA (ed25519)</td><td>✓</td><td></td><td>?</td><td></td></tr>
<tr><td>ECDSA</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>RSA</td><td>✓</td><td>✓</td><td>✓</td><td></td></tr>
<tr><td>PKCS#11 interface</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Network shareable</td><td>✓</td><td></td><td>✓</td><td></td></tr>
<tr><td>M of N wrap rule</td><td>✓</td><td>✓</td><td></td><td></td></tr>
<tr><td>Tamper evident audit logging</td><td>✓</td><td></td><td></td><td></td></tr>
<tr><td>Storage capacity</td><td>128KB, 255xAny ECC</td><td>76KB, 35xECC-512</td><td></td><td>9.7Kb, 16 slots</td></tr>
<tr><td>Price</td><td>650EUR (VAT 0%)</td><td>99 EUR</td><td>FOSS</td><td>HW Costs</td></tr>
</tbody></table>
</div>
<p>YubiHSM2 is the leading solution considering its cryptographic capabilities. However, taking into account quite modest needs of SCS, NitrokeyHSM2 represents an adequate option. </p>
<p>The main benefit of YubiHSM2 from SCS perspective is its native support of EdDSA-curve25519, which is the one that NixOS is using for package signing. Thus YubiHSM2 could be used directly with NixOS. However, as the package doesn't change in transit from the Build System to the Consumer, usage of inbuilt tooling is not always necessary.</p>
<p>BreadboardHSM solution is based on Microchip ATECC608B (TrustFLEX + cryptoauthlib + gtutls), though development work is still ongoing at the time of writing this document. The SoftHSMv2 and BreadboardHSM are taken for comparison showing what can be achieved using FOSS variants. </p>
<h2 id="ca-hierarchy-options"><a class="header" href="#ca-hierarchy-options">CA Hierarchy Options</a></h2>
<p>CA usually consists of:</p>
<ul>
<li>Root CA - the root of trust of the entire PKI, for issuing and signing the certificates used by other CAs.</li>
<li>Subordinate CA for issuing end-entity certificates.</li>
</ul>
<p>There are three types of hierarchies: one-tier, two-tier, and three-tier. The hierarchy can be chosen based on the target project's needs and complexity. A one-tier hierarchy is not considered for any production usage due to the low security, as the compromise of a single CA leads to a compromise of the entire PKI.</p>
<p>In a two-tier hierarchy, the Root CA and issuing (Subordinate) CAs are separated for increasing the security level. This is the simplest production level hierarchy allowing to keep Root CA at the most secure and restrictive levels, yet making subordinate CA access slightly more permissive. This hierarchy is most likely sufficient for most of the target projects.</p>
<p>In a three-tier CA, an intermediate CA is placed between the Root CA and the Subordinate (issuing) CA. This is done to separate the Root CA from low-level CA operations. The middle layer (intermediate CA) is only used to sign Subordinate CAs that issue the end-entity certificates. </p>
<h2 id="proposed-ca-hierarchy"><a class="header" href="#proposed-ca-hierarchy">Proposed CA Hierarchy</a></h2>
<p>The following diagram describes the proposed CA for the SCS. The three-tier CA is chosen based on the high-security level and the potential need to scale it to several projects, later on, keeping the main control under the same Root CA.</p>
<p><img src="scs/../img/ca_implementation.drawio.png" alt="Proposed CA" title="CA Implementation Proposal" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patch-management-automation"><a class="header" href="#patch-management-automation">Patch Management Automation</a></h1>
<p>An automated patch management solution increases complex software development efficiency concurrently ensuring a high level of vulnerability remediation in a reasonable time frame.</p>
<p><img src="scs/../img/autopatching.drawio.png" alt="Patch Management Automation" title="Automated Patch Management Solution" /></p>
<p>The patch management automation (PMA) system processes data in cycles. Every cycle includes a number of stages:</p>
<ol>
<li>The developer submits the change to the repository. Hydra builds the package from the source.</li>
<li>The Vulnerability Analysis (VA) component scans each software artifact for vulnerabilities immediately after the build.</li>
<li>If new vulnerabilities are discovered, the PMA system scans each dependency provenance for the update availability.</li>
<li>If update availability exists, the PMA system downloads new dependencies, and Hydra builds the new package.</li>
<li>The package is rebuilding with updated dependencies that may affect functionality. The PMA system starts the package regression testing.</li>
<li>A package passing the testing will be presented to the concerned developers for review and approval. The SBOM, scan and test results along with the package are published to a web server. The developer downloads the artifacts for review and approval.</li>
<li>All approved artifacts become release candidates and can be found on the web server.</li>
</ol>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="dependency-tracking"><a class="header" href="#dependency-tracking">Dependency Tracking</a></h3>
<p>The dependency tracking solution is based on Package URL (PURL), natively supported by ClyconeDX. PURL is a URL, composed of seven components:</p>
<p><code>scheme:type/namespace/name@version?qualifiers#subpath</code></p>
<ul>
<li><strong>scheme</strong>: URL scheme, with the constant value &quot;pkg&quot;, facilitating the future official registration of the &quot;pkg&quot; scheme for package URLs.</li>
<li><strong>type</strong>: the package type, such as npm, maven, etc.</li>
<li><strong>namespace</strong>: name prefix. For example GitHub user, organization, etc.</li>
<li><strong>name</strong>: the name of the package.</li>
<li><strong>version</strong>: the version of the package.</li>
<li><strong>qualifiers</strong>: extra qualifying data, e.g. OS, distro, architecture, etc.</li>
<li><strong>subpath</strong>: extra subpath relative to package root.</li>
</ul>
<p>In addition to PURL, each component should contain at least one hash value, computed from cryptographic hash functions. The hash values help to verify the original package integrity and source prior to update the download. Thus minimizing security risks during the process.</p>
<h3 id="package-update"><a class="header" href="#package-update">Package Update</a></h3>
<p>The update mechanism implementation depends on a system and will differ from one build system to another.</p>
<p>For example, in Nix it is enough that respective Nix files are automatically updated and the package is rebuilt. For more information on package update steps, see the <a href="https://nixos.wiki/wiki/Update_a_package">Update a package</a> article of the NixOS Wiki.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="research-notes"><a class="header" href="#research-notes">Research Notes</a></h1>
<p>Our experience in research and lessons learned activities:</p>
<ul>
<li><a href="research/passthrough/ethernet.html">i.MX 8QM platform bus ethernet passthrough</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imx-8qm-ethernet-passthrough"><a class="header" href="#imx-8qm-ethernet-passthrough">i.MX 8QM Ethernet Passthrough</a></h1>
<p>The i.MX 8QuadMax (i.MX 8QM, iMX8QM, imx8qm) pass-through host setup relies as much as possible on the default i.MX 8QM MEK (imx8qm-mek) device tree configuration. Some guidance on what is required for passthrough to work on i.MX 8 can be found in the XEN device trees.</p>
<p>This document provides a detailed description of what has been done and why. For the more impatient readers, the example device tree files for i.MX 8QM guest and host with ethernet passthrough are available here:</p>
<ul>
<li>Full host device tree: <a href="research/passthrough/imx8qm-mek_conn-host.dts">imx8qm-mek_conn-host.dts</a></li>
<li>Full guest device tree: <a href="research/passthrough/imx8qm-mek_conn-guest.dts">imx8qm-mek_conn-guest.dts</a></li>
</ul>
<p><strong>NOTE 20.12.2022:</strong>
At the current state, the passthrough is not completely functional. The Ethernet device (fec1) or even both devices (fec1 and fec2) can be set up in the guest. The devices respond and seem functional, the device node does activate, the drivers load correctly, the power state of the device changes to active, and the link state of the ethernet connection seems to change correctly. However, for some reason, no actual ethernet data packages go through the ethernet adapter. The most visible issue is that no interrupts come to the ethernet devices.</p>
<p>See the following topics:</p>
<ul>
<li><a href="research/passthrough/ethernet.html#host-kernel-configuration">Host Kernel Configuration</a></li>
<li><a href="research/passthrough/ethernet.html#host-device-tree-explained">Host Device Tree Explained</a>
<ul>
<li><a href="research/passthrough/ethernet.html#other-notes-about-passthrough">Other Notes About Passthrough</a></li>
</ul>
</li>
<li><a href="research/passthrough/ethernet.html#changes-in-u-boot">Changes in U-Boot</a></li>
<li><a href="research/passthrough/ethernet.html#running-platform-device-passthrough-in-qemu">Running Platform Device Passthrough in QEMU</a></li>
<li><a href="research/passthrough/ethernet.html#guest-setup">Guest Setup</a>
<ul>
<li><a href="research/passthrough/ethernet.html#adding-devices-to-guest">Adding Devices to Guest</a></li>
<li><a href="research/passthrough/ethernet.html#some-final-touches-for-guest-devices">Some Final Touches for Guest Devices</a></li>
</ul>
</li>
<li><a href="research/passthrough/ethernet.html#compiling-the-device-tree-source-to-binary-form">Compiling the Device Tree Source to Binary Form</a>
<ul>
<li><a href="research/passthrough/ethernet.html#compiling-for-guest">Compiling for Guest</a></li>
<li><a href="research/passthrough/ethernet.html#compiling-for-host">Compiling for Host</a></li>
</ul>
</li>
<li><a href="research/passthrough/ethernet.html#running-quemu-with-pass-through-platform-devices">Running QEMU with Pass-through Platform Devices</a></li>
</ul>
<hr />
<h2 id="host-kernel-configuration"><a class="header" href="#host-kernel-configuration">Host Kernel Configuration</a></h2>
<p>Kernel version 5.10 was used during the setup. For the passthrough to work, a few kernel configuration options need to be added to the default i.MX 8QM configuration:</p>
<ul>
<li>CONFIG_VFIO_PLATFORM=y</li>
<li>CONFIG_IOMMU_DEFAULT_PASSTHROUGH=y</li>
<li>CONFIG_VFIO_PLATFORM=y</li>
<li>CONFIG_ARM_SMMU_V3_SVA=y</li>
</ul>
<h2 id="host-device-tree-explained"><a class="header" href="#host-device-tree-explained">Host Device Tree Explained</a></h2>
<p>The default Freescale i.MX 8QM MEK configuration is included and then updated to get the ethernet device pass-through configuration added on top of the original device configuration.</p>
<p>There are two problems with using the i.MX 8 XEN configuration as reference. The first issue is that the configuration between XEN and KVM do not map one to one. The second issue is more specific to ethernet pass-through as i.MX 8 XEN configuration does not set up pass-through for ethernet so most of the configuration needs to be figured out from scratch.</p>
<pre><code>#include &quot;freescale/imx8qm-mek.dts&quot;
/ {
    domu {
        /*
        * There are 5 MUs, 0A is used by Dom0, 1A is used
        * by ATF, so for DomU, 2A/3A/4A could be used.
        * SC_R_MU_0A
        * SC_R_MU_1A
        * SC_R_MU_2A
        * SC_R_MU_3A
        * SC_R_MU_4A
        * The rsrcs and pads will be configured by uboot scu_rm cmd
        */
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;
        doma {
            compatible = &quot;xen,domu&quot;;
            /*
            * The name entry in VM configuration file
            * needs to be same as here.
            */
            domain_name = &quot;DomU&quot;;
            /*
            * The reg property will be updated by U-Boot to
            * reflect the partition id.
            */
            reg = &lt;0&gt;;
            
            /*
            * Initialize and activate the Mailbox MU2A at boot
            */
            init_on_rsrcs = &lt;
                IMX_SC_R_MU_2A
            &gt;;

            /*
            * Mark the Mailbox and Ethernet adapter power domains available to guest
            */
            rsrcs = &lt;
                IMX_SC_R_MU_2A
                IMX_SC_R_ENET_0
            &gt;;

            /* 
            * Mark the pads for ethernet adapter fec1 available to guest
            */
            pads = &lt;
                IMX8QM_ENET0_MDIO
                IMX8QM_ENET0_MDC
                IMX8QM_ENET0_REFCLK_125M_25M

                IMX8QM_ENET0_RGMII_TXC
                IMX8QM_ENET0_RGMII_TX_CTL
                IMX8QM_ENET0_RGMII_TXD0
                IMX8QM_ENET0_RGMII_TXD1
                IMX8QM_ENET0_RGMII_TXD2
                IMX8QM_ENET0_RGMII_TXD3
                IMX8QM_ENET0_RGMII_RXC
                IMX8QM_ENET0_RGMII_RX_CTL
                IMX8QM_ENET0_RGMII_RXD0
                IMX8QM_ENET0_RGMII_RXD1
                IMX8QM_ENET0_RGMII_RXD2
                IMX8QM_ENET0_RGMII_RXD3
                IMX8QM_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB

                IMX8QM_SCU_GPIO0_07
                IMX8QM_SPI0_CS1
                IMX8QM_SPI2_CS1
                IMX8QM_SAI1_RXFS
                IMX8QM_SAI1_RXC
            &gt;;

            /* GPIOS as default from imxqm XEN device tree */
            gpios = &lt;&amp;lsio_gpio1 13 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 19 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 27 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 28 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 30 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 1 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 3 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 6 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 9 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 11 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 19 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 22 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 25 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 26 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 27 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 29 GPIO_ACTIVE_LOW&gt;;
        };
    };
};

/*
 * Add iommus property for the passed through device nodes to allow setting up vfio  
 * The device type &quot;compatible&quot; is changed to prevent the system from loading a  
 * driver the the adapter.  
 * Most other properties are removed from the adapter.
 */
&amp;fec1 {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = &quot;fsl,dummy&quot;;
    status = &quot;okay&quot;;

    /delete-property/ power-domains;
    /delete-property/ clocks;
    /delete-property/ clock-names;
    /delete-property/ assigned-clocks;
    /delete-property/ assigned-clock-rates;
    /delete-property/ phy-handle;
    /delete-property/ pinctrl-names;
    /delete-property/ pinctrl-0;
};

/* 
 * The device is not being used by guest. Just to make sure it is removed from iommu
 * group and disabled.
 */
&amp;fec2 {
    /delete-property/ iommus;
    status = &quot;disabled&quot;;
};

/*
 * Timer device for fec1
&amp;enet0_lpcg {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = &quot;fsl,dummy&quot;;
    status = &quot;okay&quot;;
    /delete-property/ power-domains;
    /delete-property/ clocks;
    /delete-property/ clock-names;
    /delete-property/ assigned-clocks;
    /delete-property/ assigned-clock-rates;
    /delete-property/ pinctrl-0;
};

&amp;enet1_lpcg {
    /delete-property/ iommus;
    status = &quot;disabled&quot;;
};

&amp;lsio_mu2 {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = &quot;fsl,dummy&quot;;
    status = &quot;okay&quot;;
};

/*
* Remove iommus properties from other devices which are not passed through for  Network VM
*/
&amp;usdhc1 {
    /delete-property/ iommus;
};

&amp;usdhc2 {
    /delete-property/ iommus;
};

&amp;usdhc3 {
    /delete-property/ iommus;
};

&amp;sata {
    /delete-property/ iommus;
};

&amp;usbotg3 {
    /delete-property/ iommus;
};

&amp;usbotg3_cdns3 {
    /delete-property/ iommus;
};
</code></pre>
<h3 id="other-notes-about-passthrough"><a class="header" href="#other-notes-about-passthrough">Other Notes About Passthrough</a></h3>
<ul>
<li>All devices which belong to the same VFIO/IOMMU group need to be passed through to the guest.</li>
<li>To prevent the device from being initialized by the host, change the device-compatible property to a dummy such as &quot;fsl,dummy&quot;.</li>
<li>The device status need needs to be &quot;okay&quot; for the device node to be available.</li>
<li>If U-Boot finds devices that appear in the doma <em>rsrcs</em> that contain the properties listed below, the device will get removed from the DTB:
<ul>
<li>power-domains</li>
<li>clocks</li>
<li>clock-names</li>
<li>assigned-clocks</li>
<li>assigned-clock-rates</li>
<li>pinctrl-0</li>
</ul>
</li>
</ul>
<h2 id="changes-in-u-boot"><a class="header" href="#changes-in-u-boot">Changes in U-Boot</a></h2>
<p>In our host device tree, we defined a couple of &quot;rsrcs&quot; resources to be handed over to the guest system. The ownership of these registers needs to be transferred to the guest after loading our device tree and before the actual boot. This can be done in U-Boot with a command:</p>
<pre><code>scu_rm dtb ${fdt_addr}
</code></pre>
<p>The easiest way to accomplish this automatically during boot is to add the &quot;scu_rm&quot; to the default i.MX 8QM U-Boot &quot;boot_os&quot; command and save the changes as below:</p>
<pre><code>setenv boot_os 'scu_rm dtb ${fdt_addr}; booti ${loadaddr} - ${fdt_addr};'
saveenv
</code></pre>
<h2 id="running-platform-device-passthrough-in-qemu"><a class="header" href="#running-platform-device-passthrough-in-qemu">Running Platform Device Passthrough in QEMU</a></h2>
<p>Before you start QEMU, the passed-through devices need to be bind to the VFIO driver.</p>
<p>In some cases, the default driver needs to be unbind before the device can be bind to VFIO. However, in this case, all devices were changed to use the dummy device type in the device tree, so the step below is not required for this setup.</p>
<pre><code>echo 5d1d0000.mailbox &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver/unbind
echo 5b040000.ethernet &gt; /sys/bus/platform/devices/5b040000.ethernet/driver/unbind
echo 5b230000.clock-controller &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver/unbind
</code></pre>
<p>The VFIO driver allows user-level access to the devices. Binding required devices to VFIO can be done as below:</p>
<pre><code>echo vfio-platform  &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver_override
echo 5d1d0000.mailbox &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b040000.ethernet/driver_override
echo 5b040000.ethernet &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver_override
echo 5b230000.clock-controller &gt; /sys/bus/platform/drivers/vfio-platform/bind
</code></pre>
<p>After binding the devices to VFIO so it is possible to pass the devices to QEMU using &quot;<strong>-device vfio-platform</strong>&quot; arguments as below. The order in which the device arguments are given to QEMU may have an effect on some device properties such as interrupts.</p>
<pre><code>-device vfio-platform,host=5b230000.clock-controller
-device vfio-platform,host=5b040000.ethernet
-device vfio-platform,host=5d1d0000.mailbox
</code></pre>
<h2 id="guest-setup"><a class="header" href="#guest-setup">Guest Setup</a></h2>
<p>Before starting the virtual machine with passed-through devices, we need to define our virtual machine device tree. One way of gaining a template for our QEMU device tree is by starting our QEMU instance and requesting a dump of its device tree in the DTB format as below.</p>
<p>DTB is a binary format of the device tree so we also need to use the command line tool device tree compiler <strong>dtc</strong> to convert the binary device tree to a more human-friendly device tree source format. Converting the device tree to source format may give a few warnings of missing or unrecognized properties and such but that is normal.</p>
<pre><code>qemu-system-aarch64 \
    -M virt,gic-version=host,dumpdtb=virt.dtb -enable-kvm -nographic

# Convert binary to source device tree format
dtc -I dtb -O dts virt.dtb &gt; virt.dts
</code></pre>
<p>This will provide us with a &quot;<strong>virt.dts</strong>&quot; file which can be used as a base for adding our passed-through devices. The U-Boot device tree may change based on U-Boot version so the guest device tree may need some maintenance every now and then.</p>
<h3 id="adding-devices-to-guest"><a class="header" href="#adding-devices-to-guest">Adding Devices to Guest</a></h3>
<p>The platform devices which are going to get passed through should be added to the QEMU device tree <strong>platform</strong> bus section.</p>
<p>In this case, the main devices are <strong>fec1</strong>, <strong>enet0_lpcg</strong> and <strong>lsio_mu2</strong>. At the time of writing, the platform bus address in QEMU is &quot;<strong>c000000</strong>&quot; but that can be changed within the following code (needs recompiling QEMU) or it might change during some the QEMU code update.</p>
<pre><code>platform@c000000 {
	compatible = &quot;qemu,platform\0simple-bus&quot;;
	interrupt-parent = &lt;0x8001&gt;;
	#address-cells = &lt;0x02&gt;;
	#size-cells = &lt;0x02&gt;;

    /* Devices register remapping 
	// ranges = &lt;0xc000000 0x00 0xc000000 0x2000000&gt;;
	ranges = &lt;0x00 0x5b230000 0x00 0xc000000 0x00 0x10000&gt;,
			 &lt;0x00 0x5b040000 0x00 0xc010000 0x00 0x10000&gt;,
			 &lt;0x00 0x5d1d0000 0x00 0xc020000 0x00 0x10000&gt;;

    /*
    * Fec1 device configuration
    * Mostly the same that was set in the original host device configuration
    * The original interrupts can be left here as reference but they are updated at the end of config
    */
    fec1: ethernet@5b040000 {
        reg = &lt;0x00 0x5b040000 0x00 0x10000&gt;;
        interrupts = &lt;GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH&gt;;
        clocks = &lt;&amp;enet0_lpcg 4&gt;,
            &lt;&amp;enet0_lpcg 2&gt;,
            &lt;&amp;enet0_lpcg 3&gt;,
            &lt;&amp;enet0_lpcg 0&gt;,
            &lt;&amp;enet0_lpcg 1&gt;;
        clock-names = &quot;ipg&quot;, &quot;ahb&quot;, &quot;enet_clk_ref&quot;, &quot;ptp&quot;, &quot;enet_2x_txclk&quot;;
        assigned-clocks = &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
                &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_C_CLKDIV&gt;;
        assigned-clock-rates = &lt;250000000&gt;, &lt;125000000&gt;;
        fsl,num-tx-queues=&lt;1&gt;;
        fsl,num-rx-queues=&lt;1&gt;;
        power-domains = &lt;&amp;pd IMX_SC_R_ENET_0&gt;;
        status = &quot;okay&quot;;
    };

    /*
    * Fec1 devices clock controller device configuration
    * Mostly the same that was set in the original host device configuration
    * The actual clocks are nor configured so those need to be added to guest
    */
    enet0_lpcg: clock-controller@5b230000 {
        compatible = &quot;fsl,imx8qxp-lpcg&quot;;
        reg = &lt;0x00 0x5b230000 0x00 0x10000&gt;;
        #clock-cells = &lt;1&gt;;
        clocks = &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
            &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
            &lt;&amp;conn_axi_clk&gt;,
            &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_C_TXCLK&gt;,
            &lt;&amp;conn_ipg_clk&gt;,
            &lt;&amp;conn_ipg_clk&gt;;
        bit-offset = &lt;0 4 8 12 16 20&gt;;
        clock-output-names = &quot;enet0_lpcg_timer_clk&quot;,
                    &quot;enet0_lpcg_txc_sampling_clk&quot;,
                    &quot;enet0_lpcg_ahb_clk&quot;,
                    &quot;enet0_lpcg_rgmii_txc_clk&quot;,
                    &quot;enet0_lpcg_ipg_clk&quot;,
                    &quot;enet0_lpcg_ipg_s_clk&quot;;
        power-domains = &lt;&amp;pd IMX_SC_R_ENET_0&gt;;
        status = &quot;okay&quot;;
    };

    /*
    * Mailbox device for Fec1 (and SCU)
    * The host needs its own Mailbox (lsio_mu1 by default) and SCU
    * The original interrupt can be left here as reference but that is updated at the end of config
    */
    lsio_mu2: mailbox@5d1d0000 {
		compatible = &quot;fsl,imx8-mu-scu&quot;, &quot;fsl,imx8qm-mu&quot;, &quot;fsl,imx6sx-mu&quot;;
		reg = &lt;0x00 0x5d1d0000 0x00 0x10000&gt;;
        interrupts = &lt;GIC_SPI 178 IRQ_TYPE_LEVEL_HIGH&gt;;
		#mbox-cells = &lt;0x02&gt;;
		status = &quot;okay&quot;;
	};
};
</code></pre>
<p>The actual devices which were passed through may have some dependencies such as clocks which also need to be configured in the guest for the main devices to work properly. In most cases, they can be just copy pasted from the original host configuration with a few minor alterations. Required dependencies need a bit of manual labor and depend on case to case.</p>
<p>The main key is to go through the whole original device tree and list out device node names that are used by the passed-through devices. This may require several passes as the dependencies may also contain some dependencies of their own. On top of the requirements, it is good also to check if the passed-through devices are used by some other devices. </p>
<p>Some devices may be used through a controller such as in our case <strong>lsio_mu2</strong> is used by the main system control unit <strong>scu</strong>. In this case, the dependencies consist of several clock devices and their controller and also the i.MX 8 system control unit <strong>SCU</strong> device with its internals.</p>
<p>In this case, the assisting devices can be added just before the start &quot;<strong>platform@c000000</strong>&quot; bus configuration section. </p>
<pre><code>/**
 * Several clocks and a regulator copied from original host config.
 **/
clk_dummy: clock-dummy {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;0&gt;;
	clock-output-names = &quot;clk_dummy&quot;;
};

xtal32k: clock-xtal32k {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;32768&gt;;
	clock-output-names = &quot;xtal_32KHz&quot;;
};

xtal24m: clock-xtal24m {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;24000000&gt;;
	clock-output-names = &quot;xtal_24MHz&quot;;
};

reg_fec2_supply: fec2_nvcc {
	compatible = &quot;regulator-fixed&quot;;
	regulator-name = &quot;fec2_nvcc&quot;;
	regulator-min-microvolt = &lt;1800000&gt;;
	regulator-max-microvolt = &lt;1800000&gt;;
//	gpio = &lt;&amp;max7322 0 GPIO_ACTIVE_HIGH&gt;;
	enable-active-high;
	status = &quot;okay&quot;;
};

conn_axi_clk: clock-conn-axi {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;333333333&gt;;
	clock-output-names = &quot;conn_axi_clk&quot;;
};

conn_ahb_clk: clock-conn-ahb {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;166666666&gt;;
	clock-output-names = &quot;conn_ahb_clk&quot;;
};

conn_ipg_clk: clock-conn-ipg {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;83333333&gt;;
	clock-output-names = &quot;conn_ipg_clk&quot;;
};

conn_bch_clk: clock-conn-bch {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;400000000&gt;;
	clock-output-names = &quot;conn_bch_clk&quot;;
};

/**
 * imx8 SCU device and its content with changed to use &quot;lsio_mu2&quot; mailbox
 * The original scu used lsio_mu1 so we need to use one of lsio_mu2 to lsio_mu4
 **/
scu {
	compatible = &quot;fsl,imx-scu&quot;;
	mbox-names = &quot;tx0&quot;, &quot;rx0&quot;, &quot;gip3&quot;;
	mboxes = &lt;&amp;lsio_mu2 0 0
		&amp;lsio_mu2 1 0
		&amp;lsio_mu2 3 3&gt;;

	pd: imx8qx-pd {
		compatible = &quot;fsl,imx8qm-scu-pd&quot;, &quot;fsl,scu-pd&quot;;
		#power-domain-cells = &lt;1&gt;;
		status = &quot;okay&quot;;

		wakeup-irq = &lt;235 236 237 258 262 267 271
				345 346 347 348&gt;;
	};

	clk: clock-controller {
		compatible = &quot;fsl,imx8qm-clk&quot;, &quot;fsl,scu-clk&quot;;
		#clock-cells = &lt;2&gt;;
		clocks = &lt;&amp;xtal32k &amp;xtal24m&gt;;
		clock-names = &quot;xtal_32KHz&quot;, &quot;xtal_24Mhz&quot;;
	};

	iomuxc: pinctrl {
		compatible = &quot;fsl,imx8qm-iomuxc&quot;;
	};

	ocotp: imx8qm-ocotp {
		compatible = &quot;fsl,imx8qm-scu-ocotp&quot;;
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;1&gt;;
		read-only;

		fec_mac0: mac@1c4 {
			reg = &lt;0x1c4 6&gt;;
		};

		fec_mac1: mac@1c6 {
			reg = &lt;0x1c6 6&gt;;
		};
	};

	rtc: rtc {
		compatible = &quot;fsl,imx8qm-sc-rtc&quot;;
	};

	watchdog {
		compatible = &quot;fsl,imx8qm-sc-wdt&quot;, &quot;fsl,imx-sc-wdt&quot;;
		timeout-sec = &lt;60&gt;;
	};

	tsens: thermal-sensor {
		compatible = &quot;fsl,imx-sc-thermal&quot;;
		tsens-num = &lt;6&gt;;
		#thermal-sensor-cells = &lt;1&gt;;
	};
};

/**
 * And the platform bus that was done earlier would start from here..
 */
platform@c000000 {
    ...
};
</code></pre>
<h3 id="some-final-touches-for-guest-devices"><a class="header" href="#some-final-touches-for-guest-devices">Some Final Touches for Guest Devices</a></h3>
<p>Now we have most of the actual devices setup. Some final modifications for individual devices can be done at the end of the guest device tree config. These can be done outside the main node as we just modify some node properties which are already defined.</p>
<pre><code>/**
 * For fec1 we need to update the interrupts to match the ones used by guest pass-through.
 * Most of the configuration is exactly the same that was set original imx8 config
 * Qemu starts its pass-through interrupts at 0x70 so lets change that
 * It is not strictly required to remove the possible iommus property but lets do that anyway
 */
&amp;fec1 {
    compatible = &quot;fsl,imx8qm-fec&quot;, &quot;fsl,imx6sx-fec&quot;;
    interrupts = &lt;GIC_SPI 0x70 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x71 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x72 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x73 IRQ_TYPE_LEVEL_HIGH&gt;;
    /delete-property/ iommus;
    pinctrl-names = &quot;default&quot;;
    pinctrl-0 = &lt;&amp;pinctrl_fec1&gt;;
    phy-mode = &quot;rgmii-txid&quot;;
    phy-handle = &lt;&amp;ethphy0&gt;;
    fsl,magic-packet;
    nvmem-cells = &lt;&amp;fec_mac0&gt;;
    nvmem-cell-names = &quot;mac-address&quot;;
    status = &quot;okay&quot;;

    mdio {
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;

        ethphy0: ethernet-phy@0 {
            compatible = &quot;ethernet-phy-ieee802.3-c22&quot;;
            reg = &lt;0&gt;;
            at803x,eee-disabled;
            at803x,vddio-1p8v;
            qca,disable-smarteee;
            vddio-supply = &lt;&amp;vddio0&gt;;

            vddio0: vddio-regulator {
                regulator-min-microvolt = &lt;1800000&gt;;
                regulator-max-microvolt = &lt;1800000&gt;;
            };
        };
    };
};

/**
 * Not much to do for clock controller
 * Remove the iommus as it is not needed in guest and turn the device on
 */
&amp;enet0_lpcg {
    status = &quot;okay&quot;;
    /delete-property/ iommus;
};

/**
 * Same for our mailbox
 * Update the interrupts to match next available interrupt in Qemu
 */
&amp;lsio_mu2 {
    compatible = &quot;fsl,imx8-mu-scu&quot;, &quot;fsl,imx8qm-mu&quot;, &quot;fsl,imx6sx-mu&quot;;
    interrupts = &lt;GIC_SPI 0x74 IRQ_TYPE_LEVEL_HIGH&gt;;
    /delete-property/ iommus;
    status = &quot;okay&quot;;
};

/**
 * In the host devicetree we had some pads which were transferred to guest.
 * There can be found in the original imx8 hosts config.
 **/
&amp;iomuxc {
    pinctrl-names = &quot;default&quot;;
    status = &quot;okay&quot;;

    pinctrl_fec1: fec1grp {
        fsl,pins = &lt;
            IMX8QM_COMP_CTL_GPIO_1V8_3V3_ENET_ENETA_PAD		0x000014a0
            IMX8QM_ENET0_MDC_CONN_ENET0_MDC				0x06000020
            IMX8QM_ENET0_MDIO_CONN_ENET0_MDIO			0x06000020
            IMX8QM_ENET0_RGMII_TX_CTL_CONN_ENET0_RGMII_TX_CTL	0x06000020
            IMX8QM_ENET0_RGMII_TXC_CONN_ENET0_RGMII_TXC		0x06000020
            IMX8QM_ENET0_RGMII_TXD0_CONN_ENET0_RGMII_TXD0		0x06000020
            IMX8QM_ENET0_RGMII_TXD1_CONN_ENET0_RGMII_TXD1		0x06000020
            IMX8QM_ENET0_RGMII_TXD2_CONN_ENET0_RGMII_TXD2		0x06000020
            IMX8QM_ENET0_RGMII_TXD3_CONN_ENET0_RGMII_TXD3		0x06000020
            IMX8QM_ENET0_RGMII_RXC_CONN_ENET0_RGMII_RXC		0x06000020
            IMX8QM_ENET0_RGMII_RX_CTL_CONN_ENET0_RGMII_RX_CTL	0x06000020
            IMX8QM_ENET0_RGMII_RXD0_CONN_ENET0_RGMII_RXD0		0x06000020
            IMX8QM_ENET0_RGMII_RXD1_CONN_ENET0_RGMII_RXD1		0x06000020
            IMX8QM_ENET0_RGMII_RXD2_CONN_ENET0_RGMII_RXD2		0x06000020
            IMX8QM_ENET0_RGMII_RXD3_CONN_ENET0_RGMII_RXD3		0x06000020
        &gt;;
    };
};
</code></pre>
<p>With our additional devices also some headers and definitions need to be included at the beginning of the device tree. These additions can be found also from the original i.MX 8 device tree files. See the full device tree below for reference.</p>
<h2 id="compiling-the-device-tree-source-to-binary-form"><a class="header" href="#compiling-the-device-tree-source-to-binary-form">Compiling the Device Tree Source to Binary Form</a></h2>
<p>The device trees need to be compiled within the Linux kernel source directory. They depend on some kernel device tree headers and in the host device case — other device tree source files.</p>
<ul>
<li>Full host device tree: <a href="research/passthrough/imx8qm-mek_conn-host.dts">imx8qm-mek_conn-host.dts</a></li>
<li>Full guest device tree: <a href="research/passthrough/imx8qm-mek_conn-guest.dts">imx8qm-mek_conn-guest.dts</a></li>
</ul>
<h3 id="compiling-for-guest"><a class="header" href="#compiling-for-guest">Compiling for Guest</a></h3>
<pre><code>cpp -nostdinc -I include -I arch  -undef -x assembler-with-cpp \
    arch/arm64/boot/dts/freescale/imx8qm-mek_conn-guest.dts imx8qm-mek_conn-guest.dts.preprocessed; \
    dtc -I dts -O dtb -p 0x1000 imx8qm-mek_conn-guest.preprocessed -o imx8qm-mek_conn-guest.dtb
</code></pre>
<h3 id="compiling-for-host"><a class="header" href="#compiling-for-host">Compiling for Host</a></h3>
<pre><code>cpp -nostdinc -I include -I arch  -undef -x assembler-with-cpp \
    arch/arm64/boot/dts/freescale/imx8qm-mek_conn-host.dts imx8qm-mek_conn-host.dts.preprocessed; \
    dtc -I dts -O dtb -p 0x1000 imx8qm-mek_conn-host.preprocessed -o imx8qm-mek_conn-host.dtb
</code></pre>
<h2 id="running-qemu-with-pass-through-platform-devices"><a class="header" href="#running-qemu-with-pass-through-platform-devices">Running QEMU with Pass-through Platform Devices</a></h2>
<p>To get pass-through working i.MX 8 QM needs to be booted using our freshly built hosts <strong>imx8qm-mek_conn-host.dtb</strong> device tree file.</p>
<p>When the system has booted, we need to set up the passed-through devices for the VFIO driver and start QEMU with devices passed through.</p>
<p>First, the devices need to be setup for VFIO:</p>
<pre><code>echo vfio-platform  &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver_override
echo 5d1d0000.mailbox &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b040000.ethernet/driver_override
echo 5b040000.ethernet &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver_override
echo 5b230000.clock-controller &gt; /sys/bus/platform/drivers/vfio-platform/bind
</code></pre>
<p>After that QEMU can be started with our devices over the devices.</p>
<p>This is just as an example and may require a bit of change in other environments.</p>
<p>In this example, the guest kernel image — ext2 rootfs and guest device tree — all use the same filename prefix <strong>imx8qm-mek_conn-guest</strong>.</p>
<pre><code>qemu-system-aarch64 \
    -M virt,gic-version=host -enable-kvm \
    -cpu host \
    -m 512M \
    -kernel &quot;imx8qm-mek_conn-guest.Image&quot; \
    -drive file=&quot;imx8qm-mek_conn-guest.ext2&quot;,if=virtio,format=raw -dtb &quot;imx8qm-mek_conn-guest.dtb&quot; \
    -nographic \
    -append &quot;loglevel=7 rootwait root=/dev/vda console=ttyAMA0 earlycon earlyprintk&quot; \
    -device vfio-platform,host=5b230000.clock-controller \
    -device vfio-platform,host=5b040000.ethernet \
    -device vfio-platform,host=5d1d0000.mailbox
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>This is a glossary of terms and abbreviations developed by the Ghaf team.</p>
<p><strong>Abbreviation</strong> is a shortened form of a word or phrase. Usually is used to save space and time, to avoid repetition of long words and phrases.</p>
<p>The styling of abbreviations is inconsistent and includes several possible variations. Some abbreviations are formed by omitting all but the first few letters of a word. Such abbreviations usually end in a period: Mr. for mister, Oct. for October.</p>
<p>When abbreviations are formed from the initial letters of a phrase, they are categorized as either <strong>initialisms</strong> or <strong>acronyms</strong>:</p>
<ul>
<li>
<p>With <strong>initialisms</strong>, each letter is pronounced separately. For example: FBI for Federal Bureau of Investigation, CIA for Central Intelligence Agency), CD for Compact Disk, and also OK for Okay, &quot;orl korrekt&quot; that is a misspelling of &quot;all correct&quot;. Initialisms cannot be pronounced as words.</p>
</li>
<li>
<p><strong>Acronyms</strong> are another type of abbreviation formed from the initial letters but that are pronounced as if they were words themselves. For example: ROFL for ‘rolling on the floor laughing’, FEMA for Federal Emergency Management Agency, NATO for North Atlantic Treaty Organization.</p>
</li>
</ul>
<p>All acronyms are abbreviations, but not all abbreviations are acronyms. ASAP that comes from ‘as soon as possible’ and appt (for appointment) are both considered abbreviations, but only ASAP is an acronym.</p>
<h3 id="appropriate-use-of-articles-before-abbreviations"><a class="header" href="#appropriate-use-of-articles-before-abbreviations">Appropriate Use of Articles before Abbreviations</a></h3>
<ul>
<li>Articles (a, an, the) are common with initialisms. The indefinite article should be chosen according to the first sound—not the first letter:
<ul>
<li>‘A’ is correct before initialisms beginning with a consonant sound, including a vowel pronounced as a ‘w’ or ‘y’ sound. For example: ‘a NASA launch’, but ‘NASA launches take place’.</li>
<li>When an initialism begins with a vowel sound (including silent consonants or a consonant pronounced with an initial vowel sound), ‘an’ should be used instead. For example, ‘read about an FBI raid’.</li>
</ul>
</li>
<li>Acronyms not require articles except when they are used adjectivally. For example: ‘the patient was diagnosed with AIDS’, but ‘the AIDS patient’;‘the NASA launch takes place’.</li>
</ul>
<p>So, read the abbreviation aloud: it may be either an initialism or an acronym. Focus on the sounds, not on the letters: ‘<em>an</em> unidentified flying object’ but ‘<em>a</em> UFO’ as it pronounced “a YOO-ef-OH” (/ˌjuːɛfˈəʊ/). More examples: a EULA (“YOO-luh”), a LAN router, an XML file, an HTML page.</p>
<h3 id="trivia"><a class="header" href="#trivia">Trivia</a></h3>
<p>If you do not find the term or abbreviation you are looking for, share your questions using <a href="https://github.com/tiiuae/ghaf/issues">GitHub Issues</a>.</p>
<p>Wikipedia is not a dictionary.</p>
<hr />
<h2 id="project-related"><a class="header" href="#project-related">Project Related</a></h2>
<h3 id="ghaf"><a class="header" href="#ghaf">Ghaf</a></h3>
<p><em>The project code name that represents the Ghaf tree.</em><br />
Source: <a href="https://connectwithnature.ae/knowledge-hub/ghaf-tree">https://connectwithnature.ae/knowledge-hub/ghaf-tree</a></p>
<h3 id="ssrc"><a class="header" href="#ssrc">SSRC</a></h3>
<p><em>Secure Systems Research Center is a global center of excellence in the development of end-to-end security and resilience for cyber-physical and autonomous systems. SSRC is a part of TII.</em><br />
Source: <a href="https://www.tii.ae/secure-systems">https://www.tii.ae/secure-systems</a></p>
<h3 id="tii"><a class="header" href="#tii">TII</a></h3>
<p><em>Technology Innovation Institute is a UAE-based research center that aims to lead global advances in artificial intelligence, autonomous robotics, quantum computing, cryptography and quantum communications, directed energy, secure communication, smart devices, advanced materials, and propulsion and space technologies.</em><br />
Source: <a href="https://www.tii.ae/">https://www.tii.ae/</a></p>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="tcb"><a class="header" href="#tcb">TCB</a></h3>
<p><em>Trusted computing base defines the security requirements by providing separation of users and data or resources.</em><br />
Source: <a href="https://csrc.nist.gov/csrc/media/publications/conference-paper/1998/10/08/proceedings-of-the-21st-nissc-1998/documents/early-cs-papers/dod85.pdf">Department of Defense trusted computer system evaluation criteria, DoD 5200.28-STD, 1985.</a></p>
<ul>
<li>VM — virtual machine</li>
<li>app — application</li>
<li>OS — operating system</li>
<li>ADR — <a href="https://adr.github.io/">Architecture Decision Record</a></li>
<li>KVM — Kernel-based Virtual Machine is an open-source virtualization technology built into Linux.</li>
<li>KVMS — <a href="https://github.com/jkrh/kvms">Kernel-based Virtual Machine Secured</a> is an open-source project.</li>
<li>VMM — Virtual Machine Manager</li>
<li>MMU — memory management unit</li>
<li>DMA — direct memory access</li>
<li>Spectrum </li>
<li>NixOS</li>
<li>hardened OS</li>
<li>QEMU</li>
<li>BSP — board support package</li>
<li>EULA — end-user license agreement</li>
<li>UI — user interface</li>
<li>TLS</li>
</ul>
<h2 id="scs-related"><a class="header" href="#scs-related">SCS Related</a></h2>
<ul>
<li>SCS — supply chain security</li>
<li>SBOM — software bill of materials</li>
<li>PKI — public key infrastructure</li>
<li>CA — certificate authority</li>
<li>RA — registration authority</li>
<li>SLSA — <a href="https://slsa.dev/">Supply chain Levels for Software Artifacts</a></li>
<li>PyNaCl</li>
<li>EdDSA</li>
<li>GPG</li>
<li>CMS — Certificate Management System</li>
<li>OpenSSL</li>
<li>HSM — hardware security module</li>
<li>secure cryptoprocessor</li>
<li>software artifact</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution Guidelines</a></h1>
<p>Improvements to code and documentation are welcome! We would love to get contributions from you.</p>
<p>For more information, see <a href="https://github.com/tiiuae/ghaf/blob/main/CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
<p>Some things that will increase the chance that your pull request is accepted faster:</p>
<ul>
<li>Spelling tools usage.</li>
<li><a href="https://github.com/tiiuae/ghaf/blob/main/docs/style_guide.md">Following our Style Guide</a>.</li>
<li><a href="https://github.com/tiiuae/ghaf/blob/main/CONTRIBUTING.md#commit-message-guidelines">Writing a good commit message</a>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
