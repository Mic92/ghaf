<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ghaf - Documentation for TII SSRC Secure Tech</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="architecture/architecture.html"><strong aria-hidden="true">2.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/adr.html"><strong aria-hidden="true">2.1.</strong> Decision Record</a></li></ol></li><li class="chapter-item expanded "><a href="technologies.html"><strong aria-hidden="true">3.</strong> Technologies</a></li><li class="chapter-item expanded "><a href="build_configurations.html"><strong aria-hidden="true">4.</strong> Build Configurations</a></li><li class="chapter-item expanded "><a href="scs/scs.html"><strong aria-hidden="true">5.</strong> Supply Chain Security</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scs/slsa-framework.html"><strong aria-hidden="true">5.1.</strong> SLSA Framework</a></li><li class="chapter-item expanded "><a href="scs/basics.html"><strong aria-hidden="true">5.2.</strong> Basic Security Measures</a></li><li class="chapter-item expanded "><a href="scs/pki.html"><strong aria-hidden="true">5.3.</strong> Public Key Infrastructure</a></li><li class="chapter-item expanded "><a href="scs/patching-automation.html"><strong aria-hidden="true">5.4.</strong> Patch Management Automation</a></li></ol></li><li class="chapter-item expanded "><a href="research/research.html"><strong aria-hidden="true">6.</strong> Research Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="research/pass-through/ethernet.html"><strong aria-hidden="true">6.1.</strong> IMX8qm ethernet passthrough</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ghaf - Documentation for TII SSRC Secure Tech</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Secure Tech-project studies secure technologies in the context of embedded virtualization. This documentation-project, named after Ghaf tree, provides a landing site to our work. Our applied software research supports <a href="https://www.tii.ae/secure-systems">Secure Systems Research Center</a> focus areas.</p>
<h2 id="embedded-virtualization"><a class="header" href="#embedded-virtualization">Embedded Virtualization</a></h2>
<p>Embedded virtualization builds on cloud technologies in the development of end-to-end security. With hardware support for virtualization, we provide hardened system of small trusted computing base (TCB) - thin host - that enables isolation of use cases and their resources. Use cases are protected in guest virtual machines. Embedded targets small devices - personal or headless - instead of high performance cloud servers. Our scope is illustrated in the following diagram.</p>
<p><img src="img/overview.png" alt="Scope!" /></p>
<h2 id="reference-implementation"><a class="header" href="#reference-implementation">Reference Implementation</a></h2>
<p>//Our work in progress reference implementation on NXP i.MX8 is available <a href="https://github.com/tiiuae/spectrum-config-imx8">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The main architectural concept of the Ghaf platform is to break up the traditional monolithic structure to modularized components, virtual machines (VM). These VMs on hardened host OS implement the Ghaf edge virtualization platform. The Ghaf platform components are used in reference configurations to build images for reference devices. See <a href="architecture/../build_configurations.html">build configurations</a> for more info.</p>
<p>See <a href="architecture/adr.html">architectural decisions record</a> for more info on design choices that address architectural requirements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-decision-record"><a class="header" href="#architecture-decision-record">Architecture Decision Record</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p><a href="https://adr.github.io">Architecture decision records (ADR)</a> are used to constitute the Ghaf platform decision log.</p>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Contributions to Ghaf architecture decisions are welcome. Please create an architectural decision proposal by opening a pull request using the <a href="https://github.com/tiiuae/build-configurations/blob/main/adr/template.md">template</a> to <a href="https://github.com/tiiuae/build-configurations">build configurations</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="technologies"><a class="header" href="#technologies">Technologies</a></h1>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Embedded virtualization builds on technologies from cloud security. Cloud services provide scalable but isolated computation - your business case is isolated from someone else's business case. At hardware level. Similarly, hardware support in modern personal devices has enabled isolation of device resources with virtualization. This provides the baseline for secure system design for use case protection. In practice, user can use the same device with a trusted application and with an untrusted application. Both application isolated from each other to protect valuable user data and privacy. Our systems are built using <a href="https://github.com/NixOS/nixpkgs">nixpkgs</a> and various <a href="https://nixos.org/guides/nix-language.html">Nix</a> based tools and configurations.</p>
<h2 id="hardware-requirements-for-virtualization"><a class="header" href="#hardware-requirements-for-virtualization">Hardware Requirements for Virtualization</a></h2>
<p>Protected computation resources include: CPU, memory, storage and other IO devices. Allocation of these resources is managed with hypervisor. In our reference implementation, we use KVM (Kernel Virtual Machine) from Linux to virtualize hardware access. From hardware, this requires MMU (memory management unit) for CPU physical to virtual address mapping and IOMMU for direct memory access (DMA) capable device virtual addresses to physical addresses of the main memory. Many 64-bit CPUs support virtualization via hypervisor extensions already. Our reference implementation supports x86_64 and aarch64 and we follow RISC-V hypervisor extensions development.</p>
<p>Our current reference hardware is <a href="https://github.com/tiiuae/spectrum-config-imx8">NXP iMX8 QM development board</a>. In addition, x86_64 hardware is supported via Spectrum OS upstream.</p>
<h2 id="virtual-machine-manager-vmm"><a class="header" href="#virtual-machine-manager-vmm">Virtual Machine Manager (VMM)</a></h2>
<p>On top of operating system (OS) kernel hypervisor support with KVM - we allocate virtual resources for use cases with user space virtual machine manager (VMM) using <a href="https://github.com/rust-vmm">rust-vmm</a> based projects such as <a href="https://github.com/cloud-hypervisor/cloud-hypervisor">cloud-hypervisor</a> and <a href="https://github.com/google/crosvm">crosvm</a>. <a href="https://www.qemu.org/">QEMU</a> is enabled for certain development use cases. In addition, we have also experimental, aarch64 demonstrated support for a KVM variant - <a href="https://github.com/jkrh/kvms">KVMS</a> which adds security features to standard KVM.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-configurations"><a class="header" href="#build-configurations">Build Configurations</a></h1>
<p>Our hardened operating system (OS) targets are build configurations based on NixOS. The canonical URL for the upstream git repository is: https://github.com/NixOS.</p>
<p>Build configurations define our dependencies and configuration changes to packages and build mechanisms of NixOS. If you want to try and check the details, see <a href="https://github.com/tiiuae/build-configurations/">build-configurations</a> repository.</p>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>A build configuration is a target to build our hardened OS for a particular hardware device. The supported development target devices are listed in the <a href="https://github.com/tiiuae/build-configurations/">build-configurations</a>. The packages used in a build configuration comes from <a href="https://github.com/NixOS/nixpkgs">nixpkgs - NixOS Packages collection</a>. Upstream first approach means we aim the fix issues by contributing to nixpkgs. At the same time we get the maintenance support of NixOS community and the benefits of Nix language on how to build packages and track the origins of packages in software supply chain security.</p>
<p>NixOS, a Linux os distribution packaged with Nix, provides us with:</p>
<ul>
<li>generic hardware architecture support (<code>x86_64</code> and <code>aarch64</code>)</li>
<li>declarative and modular mechanism to describe the system</li>
<li>Nix packaging language mechanisms
<ul>
<li>to extend and change packages with <a href="https://nixos.wiki/wiki/Overlays">overlays</a></li>
<li>to <a href="https://nixos.org/guides/nix-pills/override-design-pattern.html">override</a> packages</li>
</ul>
</li>
</ul>
<p>Even when unmodified upstream are often preferred, even ideal, to ensure timely security updates from upstream - the customizations are sometimes required.</p>
<p>For example, to support a reference board without vendor board support package (BSP) - bootloader, kernel, device drivers - is often not feasible. With this approach we can overlay generic NixOS linux kernel with the vendor kernel and add vendor bootloader to build a target image. Often the vendor BSPs are also open source but sometimes contain unfree binary blobs from the HW vendor. Those are handled by allowing <code>unfree</code> - if user agrees with the end-user license agreement (EULA). If not, <code>unfree</code> support can be dropped along with that part of the BSP support. Same goes with the architectural variants - headless devices or end-user devices - differ in terms what kind of virtual machines (VM) they contain. User needs graphics architecture and supporting VMs for the user interface (UI) where a headless device is more like a small server without the UI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supply-chain-security"><a class="header" href="#supply-chain-security">Supply Chain Security</a></h1>
<p>To be aware of what is exactly in our software supply chain, it is reviewed for security issues and known vulnerabilities.</p>
<p><img src="scs/../img/threat_processing.png" alt="Supply Chain Attacks" /></p>
<p>We implement a <em>supply chain security (SCS)</em> — process of securing the machinery of the development, building and release environment. That means that every component that a software artifact might be touching on its way from the developer to the consumer will be secured.</p>
<p>The software artifact should be encrypted on each possible transition phase and its integrity should be verified at each destination. Each build should be accompanied by means of <a href="https://fossa.com/blog/software-bill-of-materials-formats-use-cases-tools/"><em>software bill of materials (SBOM)</em></a>, identifying all the components that the software package consists of.</p>
<p>SBOM containing reference to each dependency, its source and version together with provenance, containing build information are collected at the build time, signed and used for vulnerability analysis during the next steps.</p>
<p>The software artifact, SBOM and provenance are signed by the build machinery at the build time, and the signature is verifiable at every destination of the package. The certificates that are used for signing and verification are provided by the <em>public key infrastructure (PKI)</em> system and are signed by the same root <em>certificate authority (CA)</em>. It allows easily confirm the signature author (build machinery) and guarantee that the package has not been tampered with since the build time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slsa-framework"><a class="header" href="#slsa-framework">SLSA Framework</a></h1>
<p>Supply chain Levels for Software Artifacts (SLSA) is a security framework for tampering prevention, integrity improvement and securing packages and infrastructure of a project. More information about SLSA framework can be found from SLSA official <a href="https://slsa.dev">SLSA</a> website.</p>
<h2 id="slsa-terminology"><a class="header" href="#slsa-terminology">SLSA Terminology</a></h2>
<p><strong>Immutable reference:</strong> An identifier, guaranteed to always point to the same, immutable artifact.</p>
<p><strong>Provenance:</strong> Metadata about how an artifact was produced.</p>
<p><strong>Revision:</strong> An immutable, coherent state of a source.</p>
<h2 id="levels-of-assurance"><a class="header" href="#levels-of-assurance">Levels of Assurance</a></h2>
<p>One of the requirements for the solution is to reach SLSA Level 4 and even go beyond that. This requires a lot of process changes as well as technical work. </p>
<p>The SLSA model consists of 4 levels, offering an incremental level of anti-tampering protection. Levels 1-3 represent milestones with certain integrity guarantees, whereas level 4 is an ideal end state.</p>
<p><strong>Level 0</strong> means no SLSA compliance and no guarantees are given.</p>
<p><strong>Level 1</strong> demands a fully scripted/automated build process and provenance generation. It offers basic confidence in the origin of the software but doesn’t provide any tamper resistance.</p>
<p><strong>Level 2</strong> Introduces authenticated provenance generated by a hosted build at the same time demanding version control system usage. Provenance prevents tampering and offers trust in the build service.</p>
<p><strong>Level 3</strong> offers auditability of the source and the integrity of the provenance. Much stronger tampering protection is provided by preventing specific classes of threats such as cross-build contamination.</p>
<p><strong>Level 4</strong> requires two-peer source code review and a hermetic, reproducible build process. Overall Level 4 offers a high degree of confidence in the anti-tampering protection of the software.</p>
<p>SLSA level is not transitive, thus level of the artifact is not dependent on the level of dependencies, which are expected to have their own SLSA levels. This makes it possible to build a Level 4 artifact from Level 0 dependencies. </p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Requirements</th><th>Level 1</th><th>Level 2</th><th>Level 3</th><th>Level 4</th></tr></thead><tbody>
<tr><td>Source — <a href="https://slsa.dev/spec/v0.1/requirements#version-controlled">Version controlled</a></td><td></td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Source — <a href="https://slsa.dev/spec/v0.1/requirements#verified-history">Verified history</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Source — <a href="https://slsa.dev/spec/v0.1/requirements#retained-indefinitely">Retained indefinitely</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Source — <a href="https://slsa.dev/spec/v0.1/requirements#two-person-reviewed">Two-person reviewed</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#scripted-build">Scripted build</a></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#build-service">Build service</a></td><td></td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#build-as-code">Build as code</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#ephemeral-environment">Ephemeral environment</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#isolated">Isolated</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#parameterless">Parameterless</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#hermetic">Hermetic</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Build — <a href="https://slsa.dev/spec/v0.1/requirements#reproducible">Reproducible</a></td><td></td><td></td><td></td><td>○</td></tr>
<tr><td>Provenance — <a href="https://slsa.dev/spec/v0.1/requirements#available">Available</a></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Provenance — <a href="https://slsa.dev/spec/v0.1/requirements#authenticated">Authenticated</a></td><td></td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Provenance — <a href="https://slsa.dev/spec/v0.1/requirements#service-generated">Service generated</a></td><td></td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Provenance — <a href="https://slsa.dev/spec/v0.1/requirements#non-falsifiable">Non-falsifiable</a></td><td></td><td></td><td>✓</td><td>✓</td></tr>
<tr><td>Provenance — <a href="https://slsa.dev/spec/v0.1/requirements#dependencies-complete">Dependencies complete</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Common — <a href="https://slsa.dev/spec/v0.1/requirements#security">Security</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Common — <a href="https://slsa.dev/spec/v0.1/requirements#access">Access</a></td><td></td><td></td><td></td><td>✓</td></tr>
<tr><td>Common — <a href="https://slsa.dev/spec/v0.1/requirements#superusers">Superusers</a></td><td></td><td></td><td></td><td>✓</td></tr>
</tbody></table>
</div>
<p>✓ — Required</p>
<p>○ — Required unless justified otherwise</p>
<p>Empty cell — not required</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-security-measures"><a class="header" href="#basic-security-measures">Basic Security Measures</a></h1>
<h2 id="source-code--version-control-security"><a class="header" href="#source-code--version-control-security">Source Code / Version Control Security</a></h2>
<p>The source code security is based on the fact that the source code is two-person reviewed, version controlled, and the history is verified and retained indefinitely.</p>
<h3 id="commit-signing"><a class="header" href="#commit-signing">Commit Signing</a></h3>
<p>All the commits to repositories must be GPG-signed. This can be achieved by enabling GPG commit signatures in the config:</p>
<p><code>git config --global commit.gpgsign true</code></p>
<p>More detailed information for GitHub is available on: <a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits" title="Signing Commits on GitHub">Signing Commits on GitHub</a> </p>
<h3 id="branch-protection"><a class="header" href="#branch-protection">Branch Protection</a></h3>
<p>In the case of GitHub the following settings should be considered:</p>
<ul>
<li>Require pull request reviews before merging (req: two-person reviewed source)</li>
<li>Require status checks before merging</li>
<li>Require conversation resolution before merging</li>
<li>Require signed commits ()</li>
<li>Deletions should be forbidden (req: immutable history)</li>
</ul>
<h2 id="software-signing"><a class="header" href="#software-signing">Software Signing</a></h2>
<p>Software signing is an important measure to validate the author and ensure that the code has not been altered on the way from the developer to the customer. Nix tooling is offering means to sign the derivations using libsodium with EdDSA, however, as the modular system is assumed, scripts need to be developed to support signing mechanisms in an absence of Nix tooling.</p>
<p>By default, the software image is signed only at the binary cache per request. Which leaves the path from Hydra to the binary cache unsecured. The problem can be resolved in two ways:</p>
<ul>
<li>Enabling the image signing on Hydra</li>
<li>Shared Nix Store</li>
</ul>
<p>The second option is rather straightforward. Enabling the image signing on Hydra requires some extra work due to the lack of support of image signing at Hydra at the time of writing this document. As already mentioned, NixOS is using libsodium-based EdDSA solution for image signing. So similar scripts can be implemented. For example, in Python by using existing libsodium bindings, such as PyNaCl.</p>
<h2 id="data-encryption-in-transit"><a class="header" href="#data-encryption-in-transit">Data Encryption in Transit</a></h2>
<p>All the data should be transported over secure encrypted channels. Since all the transportation is done over TCP/IP protocol stack, it is possible to use native solutions like TLS to secure the traffic between the nodes. Version 1.2 is a minimum requirement.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public-key-infrastructure"><a class="header" href="#public-key-infrastructure">Public Key Infrastructure</a></h1>
<p>In the SCS context a public key infrastructure (PKI) term refers to a system for the creation, storage, and distribution of digital certificates which are used to verify that a particular key belongs to a certain entity. PKI creates and manages a hierarchical set of digital certificates which map public keys to certain entities. Storage and revocation methodologies are to be defined.</p>
<p>The PKI of SCS should consist of:</p>
<ul>
<li>Certificate authority (CA) for storing, issuing, and signing the digital certificates</li>
<li>Registration authority (RA) for requesting entity identity verification</li>
<li>Central directory for the secure storage of the keys</li>
<li>Certificate Management System (CMS) for managing access to stored certificates</li>
</ul>
<h2 id="private-certificate-authority-pca"><a class="header" href="#private-certificate-authority-pca">Private Certificate Authority (PCA)</a></h2>
<p>PCA enables the creation of private certificate authority hierarchies, consisting of a Root and Subordinate CAs. It issues end-entity X.509 certificates, that are used for: </p>
<ul>
<li>Encrypted TLS communication channels (data encryption in transit)</li>
<li>Code and image signing</li>
</ul>
<p>PCA can be established in the cloud or on-premises. Initially, the OpenSSL based solution deployed on-premises is assumed, however, some of the target projects might consider using commercial cloud solutions. </p>
<h2 id="hardware-security-module"><a class="header" href="#hardware-security-module">Hardware Security Module</a></h2>
<p>On-premises solution can be further improved by adding a Hardware Security Module (HSM). It is a physical device for managing cryptographic material such as digital keys. </p>
<p>HSM can be also used to perform cryptographic operations such as digital signing, encryption, and decryption. The HSM contains one or more Secure Cryptoprocessor that are dedicated microprocessors optimized for carrying out cryptographic operations. </p>
<p>One example of affordable HSM solutions is YubiHSM, developed by Yubico.</p>
<h2 id="ca-hierarchy-options"><a class="header" href="#ca-hierarchy-options">CA Hierarchy Options</a></h2>
<p>CA usually consists of:</p>
<ul>
<li>Root CA - the root of trust of the entire PKI, for issuing and signing the certificates used by other CAs</li>
<li>Subordinate CA for issuing end-entity certificates</li>
</ul>
<p>There are three types of hierarchies: one-tier, two-tier and three-tier. The hierarchy can be chosen based on the target project's needs and complexity. A one-tier hierarchy is not considered for any production usage due to the low security, as the compromise of a single CA leads to a compromise of the entire PKI.</p>
<p>In a two-tier hierarchy the Root CA and issuing (Subordinate) CAs are separated for increasing the security level. This is the simplest production level hierarchy allowing to keep Root CA at the most secure and restrictive levels, yet making subordinate CA access slightly more permissive. This hierarchy is most likely sufficient for most of the target projects.</p>
<p>In a three-tier CA an intermediate CA is placed between the Root CA and the Subordinate (issuing) CA. This is done to separate the Root CA from low-level CA operations. The middle layer (intermediate CA) is only used to sign Subordinate CAs that issue the end-entity certificates. </p>
<h2 id="proposed-ca-hierarchy"><a class="header" href="#proposed-ca-hierarchy">Proposed CA Hierarchy</a></h2>
<p>The following diagram describes the proposed CA for the SCS. The three-tier CA is chosen based on the high-security level and the potential need to scale it to several projects, later on, keeping the main control under the same Root CA.</p>
<p><img src="scs/../img/ca_implementation.drawio.png" alt="Proposed CA" title="CA Implementation Proposal" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patch-management-automation"><a class="header" href="#patch-management-automation">Patch Management Automation</a></h1>
<p>An automated patch management solution increases complex software development efficiency concurrently ensuring a high level of vulnerability remediation in a reasonable time frame.</p>
<p><img src="scs/../img/autopatching.drawio.png" alt="Patch Management Automation" title="Automated Patch Management Solution" /></p>
<p>The patch management automation (PMA) system processes data in cycles. Every cycle includes a number of stages:</p>
<ol>
<li>The developer submits the change to the repository. Hydra builds the package from the source.</li>
<li>The Vulnerability Analysis (VA) component scans each software artifact for vulnerabilities immediately after the build.</li>
<li>If new vulnerabilities are discovered, the PMA system scans each dependency provenance for the update availability.</li>
<li>If update availability exists, the PMA system downloads new dependencies, and Hydra builds the new package.</li>
<li>The package is rebuilding with updated dependencies that may affect functionality. The PMA system starts the package regression testing.</li>
<li>A package passing the testing will be presented to the concerned developers for review and approval. The SBOM, scan and test results along with the package are published to a web server. The developer downloads the artifacts for review and approval.</li>
<li>All approved artifacts become release candidates and can be found on the web server.</li>
</ol>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="dependency-tracking"><a class="header" href="#dependency-tracking">Dependency Tracking</a></h3>
<p>The dependency tracking solution is based on Package URL (PURL), natively supported by ClyconeDX. PURL is a URL, composed of seven components:</p>
<p><code>scheme:type/namespace/name@version?qualifiers#subpath</code></p>
<ul>
<li><strong>scheme</strong>: URL scheme, with the constant value &quot;pkg&quot;, facilitating the future official registration of the &quot;pkg&quot; scheme for package URLs</li>
<li><strong>type</strong>: the package type, such as npm, maven, etc</li>
<li><strong>namespace</strong>: name prefix. For example GitHub user, organization, etc</li>
<li><strong>name</strong>: the name of the package</li>
<li><strong>version</strong>: the version of the package</li>
<li><strong>qualifiers</strong>: extra qualifying data, e.g. OS, distro, architecture, etc</li>
<li><strong>subpath</strong>: extra subpath relative to package root</li>
</ul>
<p>In addition to PURL, each component should contain at least one hash value, computed from cryptographic hash functions. The hash values help verifying original package integrity and source prior to update download. Thus minimizing security risks during the process.</p>
<h3 id="package-update"><a class="header" href="#package-update">Package Update</a></h3>
<p>The update mechanism implementation is system dependent and will differ from build system to another. For example in Nix it is enough that respective nix files are automatically updated and the package is rebuilt. More information on package update steps is available in <a href="https://nixos.wiki/wiki/Update_a_package">NixOSWiki</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="research-topics"><a class="header" href="#research-topics">Research Topics</a></h1>
<ul>
<li><a href="research/pass-through/ethernet.html">Imx8qm platform bus ethernet passthrough</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imx8qm-ethernet-pass-through"><a class="header" href="#imx8qm-ethernet-pass-through">IMX8qm Ethernet Pass-through</a></h1>
<p>The imx8qm pass-through host setup relies as much as possible on the default imx8qm-mek device tree configuration. Some guidance in what is required for pass-through to work on imx8 can be found in the XEN device trees. </p>
<p>This document provides a detailed description of what has been done and why. For the more impatient readers, the example device tree files for imx8qm guest and host with ethernet pass-through are available here:</p>
<ul>
<li>Full host device tree: <a href="research/pass-through/imx8qm-mek_conn-host.dts">imx8qm-mek_conn-host.dts</a></li>
<li>Full guest device tree: <a href="research/pass-through/imx8qm-mek_conn-guest.dts">imx8qm-mek_conn-guest.dts</a></li>
</ul>
<p><strong>NOTE 20.12.2022</strong>
At the current state the pass-through is not completely functional. The Ethernet device (fec1) or even both devices (fec1 and fec2) can be setup in guest. The devices respond and seem functional, the device node does activate, the drivers load correctly, the power state of the device changes to active and the link state of the ethernet connection seems to change correctly. However for some reason no actual ethernet data packages go through the ethernet adapter. The most visible issue is that no interrupts come to the ethernet devices.</p>
<h2 id="host-kernel-configuration"><a class="header" href="#host-kernel-configuration">Host Kernel Configuration</a></h2>
<p>Kernel version 5.10 was used during the setup. For the pass-through to work a few kernel configuration options need to be added to the default imx8qm configuration.</p>
<ul>
<li>CONFIG_VFIO_PLATFORM=y</li>
<li>CONFIG_IOMMU_DEFAULT_PASSTHROUGH=y</li>
<li>CONFIG_VFIO_PLATFORM=y</li>
<li>CONFIG_ARM_SMMU_V3_SVA=y</li>
</ul>
<h2 id="host-device-tree-explained"><a class="header" href="#host-device-tree-explained">Host Device Tree Explained</a></h2>
<p>The default freescale imx8qm-mek configuration is included and then updated to get the ethernet device pass-through configuration added on top of the original device configuration.</p>
<p>There are two problems with using imx8 XEN configuration as reference. The first issue is that the configuration between XEN and KVM do not map one to one. The second issue is more specific to ethernet pass-through as imx8 XEN configuration does not set up pass-through for ethernet so most of the configuration needs to be figured out from scratch.</p>
<pre><code>#include &quot;freescale/imx8qm-mek.dts&quot;
/ {
    domu {
        /*
        * There are 5 MUs, 0A is used by Dom0, 1A is used
        * by ATF, so for DomU, 2A/3A/4A could be used.
        * SC_R_MU_0A
        * SC_R_MU_1A
        * SC_R_MU_2A
        * SC_R_MU_3A
        * SC_R_MU_4A
        * The rsrcs and pads will be configured by uboot scu_rm cmd
        */
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;
        doma {
            compatible = &quot;xen,domu&quot;;
            /*
            * The name entry in VM configuration file
            * needs to be same as here.
            */
            domain_name = &quot;DomU&quot;;
            /*
            * The reg property will be updated by U-Boot to
            * reflect the partition id.
            */
            reg = &lt;0&gt;;
            
            /*
            * Initialize and activate the Mailbox MU2A at boot
            */
            init_on_rsrcs = &lt;
                IMX_SC_R_MU_2A
            &gt;;

            /*
            * Mark the Mailbox and Ethernet adapter power domains available to guest
            */
            rsrcs = &lt;
                IMX_SC_R_MU_2A
                IMX_SC_R_ENET_0
            &gt;;

            /* 
            * Mark the pads for ethernet adapter fec1 available to guest
            */
            pads = &lt;
                IMX8QM_ENET0_MDIO
                IMX8QM_ENET0_MDC
                IMX8QM_ENET0_REFCLK_125M_25M

                IMX8QM_ENET0_RGMII_TXC
                IMX8QM_ENET0_RGMII_TX_CTL
                IMX8QM_ENET0_RGMII_TXD0
                IMX8QM_ENET0_RGMII_TXD1
                IMX8QM_ENET0_RGMII_TXD2
                IMX8QM_ENET0_RGMII_TXD3
                IMX8QM_ENET0_RGMII_RXC
                IMX8QM_ENET0_RGMII_RX_CTL
                IMX8QM_ENET0_RGMII_RXD0
                IMX8QM_ENET0_RGMII_RXD1
                IMX8QM_ENET0_RGMII_RXD2
                IMX8QM_ENET0_RGMII_RXD3
                IMX8QM_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB

                IMX8QM_SCU_GPIO0_07
                IMX8QM_SPI0_CS1
                IMX8QM_SPI2_CS1
                IMX8QM_SAI1_RXFS
                IMX8QM_SAI1_RXC
            &gt;;

            /* GPIOS as default from imxqm XEN device tree */
            gpios = &lt;&amp;lsio_gpio1 13 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 19 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 27 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 28 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 30 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 1 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 3 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 6 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 9 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 11 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 19 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 22 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 25 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 26 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 27 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 29 GPIO_ACTIVE_LOW&gt;;
        };
    };
};

/*
 * Add iommus property for the passed through device nodes to allow setting up vfio  
 * The device type &quot;compatible&quot; is changed to prevent the system from loading a  
 * driver the the adapter.  
 * Most other properties are removed from the adapter.
 */
&amp;fec1 {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = &quot;fsl,dummy&quot;;
    status = &quot;okay&quot;;

    /delete-property/ power-domains;
    /delete-property/ clocks;
    /delete-property/ clock-names;
    /delete-property/ assigned-clocks;
    /delete-property/ assigned-clock-rates;
    /delete-property/ phy-handle;
    /delete-property/ pinctrl-names;
    /delete-property/ pinctrl-0;
};

/* 
 * The device is not being used by guest. Just to make sure it is removed from iommu
 * group and disabled.
 */
&amp;fec2 {
    /delete-property/ iommus;
    status = &quot;disabled&quot;;
};

/*
 * Timer device for fec1
&amp;enet0_lpcg {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = &quot;fsl,dummy&quot;;
    status = &quot;okay&quot;;
    /delete-property/ power-domains;
    /delete-property/ clocks;
    /delete-property/ clock-names;
    /delete-property/ assigned-clocks;
    /delete-property/ assigned-clock-rates;
    /delete-property/ pinctrl-0;
};

&amp;enet1_lpcg {
    /delete-property/ iommus;
    status = &quot;disabled&quot;;
};

&amp;lsio_mu2 {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = &quot;fsl,dummy&quot;;
    status = &quot;okay&quot;;
};

/*
* Remove iommus properties from other devices which are not passed through for  Network VM
*/
&amp;usdhc1 {
    /delete-property/ iommus;
};

&amp;usdhc2 {
    /delete-property/ iommus;
};

&amp;usdhc3 {
    /delete-property/ iommus;
};

&amp;sata {
    /delete-property/ iommus;
};

&amp;usbotg3 {
    /delete-property/ iommus;
};

&amp;usbotg3_cdns3 {
    /delete-property/ iommus;
};
</code></pre>
<h3 id="other-notes-about-pass-through"><a class="header" href="#other-notes-about-pass-through">Other Notes About Pass-through</a></h3>
<ul>
<li>All devices which belong to same VFIO/IOMMU group need to be passed through to guest</li>
<li>To prevent the device being initialized by host change the device compatible property to dummy such as &quot;fsl,dummy&quot;</li>
<li>The device status need needs to be &quot;okay&quot; for the device node to be available</li>
<li>If Uboot finds devices which appear in the doma <em>rsrcs</em> that contain properties listed below the device will get removed from the DTB.
<ul>
<li>power-domains, clocks, clock-names, assigned-clocks, assigned-clock-rates, pinctrl-0</li>
</ul>
</li>
</ul>
<h2 id="changes-in-uboot"><a class="header" href="#changes-in-uboot">Changes in Uboot</a></h2>
<p>In our host devicetree we defined a couple of &quot;rsrcs&quot; -resources to be handed over to the guest system. The ownership of these registers need to transferred to guest after loading our device tree and before actual boot. This can be done in uboot with a command:</p>
<pre><code>scu_rm dtb ${fdt_addr}
</code></pre>
<p>The easiest way to accomplish this automatically during boot is to add the &quot;scu_rm&quot; to the default imx8qm uboot &quot;boot_os&quot; command and save the changes as below:</p>
<pre><code>setenv boot_os 'scu_rm dtb ${fdt_addr}; booti ${loadaddr} - ${fdt_addr};'
saveenv
</code></pre>
<h2 id="running-platform-device-pass-through-in-qemu"><a class="header" href="#running-platform-device-pass-through-in-qemu">Running Platform Device Pass-through in QEMU</a></h2>
<p>Before starting qemu the passed through devices need to be bind to VFIO driver.</p>
<p>In some cases the default driver needs to be unbind from before the device can be bind to VFIO. However in this case all devices were changed to use dummy device type in the device tree so for this setup the step below is not required.</p>
<pre><code>echo 5d1d0000.mailbox &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver/unbind
echo 5b040000.ethernet &gt; /sys/bus/platform/devices/5b040000.ethernet/driver/unbind
echo 5b230000.clock-controller &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver/unbind
</code></pre>
<p>The VFIO allows user level access to the devices. Binding required devices to VFIO can be done as below.</p>
<pre><code>echo vfio-platform  &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver_override
echo 5d1d0000.mailbox &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b040000.ethernet/driver_override
echo 5b040000.ethernet &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver_override
echo 5b230000.clock-controller &gt; /sys/bus/platform/drivers/vfio-platform/bind
</code></pre>
<p>After binding the devices to VFIO so it is possible to pass the devices to QEMU with using &quot;<strong>-device vfio-platform</strong>&quot; arguments as below. One key thing to notice is that the order in which the device arguments are given to QEMU may have an effect on some device properties such as interrupts.</p>
<pre><code>-device vfio-platform,host=5b230000.clock-controller
-device vfio-platform,host=5b040000.ethernet
-device vfio-platform,host=5d1d0000.mailbox
</code></pre>
<h2 id="guest-setup"><a class="header" href="#guest-setup">Guest Setup</a></h2>
<p>Before starting our virtual machine with passed through devices we need to define our virtual machine device tree. One way of gaining a template for our QEMU device tree is by starting our QEMU instance and requesting a dump of its device tree in dtb format as below. Dtb is a binary format of the device tree so we also need to use command line tool device tree compiler <strong>dtc</strong> to convert the binary devicetree to a more human friendly device tree source format. Converting the device tree to source format may give a few warnings of missing or unrecognized properties and such but that is normal.</p>
<pre><code>qemu-system-aarch64 \
    -M virt,gic-version=host,dumpdtb=virt.dtb -enable-kvm -nographic

# Convert binary to source device tree format
dtc -I dtb -O dts virt.dtb &gt; virt.dts
</code></pre>
<p>This will provide us with a &quot;<strong>virt.dts</strong>&quot; file which can be used as a base for adding our passed through devices. The Uboot device tree may change based on Uboot version so the guest devicetree may need some maintenance every now and then.</p>
<h3 id="adding-devices-to-guest"><a class="header" href="#adding-devices-to-guest">Adding Devices to Guest</a></h3>
<p>The platform devices which are going to get passed through should be added to Qemu device tree <strong>platform</strong> bus section. In this case the main devices are <strong>fec1</strong>, <strong>enet0_lpcg</strong> and <strong>lsio_mu2</strong>. At the time of writing the platform bus address in Qemu is &quot;<strong>c000000</strong>&quot; but that can be changed within Qemu code (needs recompiling Qemu) or it might change during some Qemu update.</p>
<pre><code>platform@c000000 {
	compatible = &quot;qemu,platform\0simple-bus&quot;;
	interrupt-parent = &lt;0x8001&gt;;
	#address-cells = &lt;0x02&gt;;
	#size-cells = &lt;0x02&gt;;

    /* Devices register remapping 
	// ranges = &lt;0xc000000 0x00 0xc000000 0x2000000&gt;;
	ranges = &lt;0x00 0x5b230000 0x00 0xc000000 0x00 0x10000&gt;,
			 &lt;0x00 0x5b040000 0x00 0xc010000 0x00 0x10000&gt;,
			 &lt;0x00 0x5d1d0000 0x00 0xc020000 0x00 0x10000&gt;;

    /*
    * Fec1 device configuration
    * Mostly the same that was set in the original host device configuration
    * The original interrupts can be left here as reference but they are updated at the end of config
    */
    fec1: ethernet@5b040000 {
        reg = &lt;0x00 0x5b040000 0x00 0x10000&gt;;
        interrupts = &lt;GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH&gt;;
        clocks = &lt;&amp;enet0_lpcg 4&gt;,
            &lt;&amp;enet0_lpcg 2&gt;,
            &lt;&amp;enet0_lpcg 3&gt;,
            &lt;&amp;enet0_lpcg 0&gt;,
            &lt;&amp;enet0_lpcg 1&gt;;
        clock-names = &quot;ipg&quot;, &quot;ahb&quot;, &quot;enet_clk_ref&quot;, &quot;ptp&quot;, &quot;enet_2x_txclk&quot;;
        assigned-clocks = &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
                &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_C_CLKDIV&gt;;
        assigned-clock-rates = &lt;250000000&gt;, &lt;125000000&gt;;
        fsl,num-tx-queues=&lt;1&gt;;
        fsl,num-rx-queues=&lt;1&gt;;
        power-domains = &lt;&amp;pd IMX_SC_R_ENET_0&gt;;
        status = &quot;okay&quot;;
    };

    /*
    * Fec1 devices clock controller device configuration
    * Mostly the same that was set in the original host device configuration
    * The actual clocks are nor configured so those need to be added to guest
    */
    enet0_lpcg: clock-controller@5b230000 {
        compatible = &quot;fsl,imx8qxp-lpcg&quot;;
        reg = &lt;0x00 0x5b230000 0x00 0x10000&gt;;
        #clock-cells = &lt;1&gt;;
        clocks = &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
            &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
            &lt;&amp;conn_axi_clk&gt;,
            &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_C_TXCLK&gt;,
            &lt;&amp;conn_ipg_clk&gt;,
            &lt;&amp;conn_ipg_clk&gt;;
        bit-offset = &lt;0 4 8 12 16 20&gt;;
        clock-output-names = &quot;enet0_lpcg_timer_clk&quot;,
                    &quot;enet0_lpcg_txc_sampling_clk&quot;,
                    &quot;enet0_lpcg_ahb_clk&quot;,
                    &quot;enet0_lpcg_rgmii_txc_clk&quot;,
                    &quot;enet0_lpcg_ipg_clk&quot;,
                    &quot;enet0_lpcg_ipg_s_clk&quot;;
        power-domains = &lt;&amp;pd IMX_SC_R_ENET_0&gt;;
        status = &quot;okay&quot;;
    };

    /*
    * Mailbox device for Fec1 (and SCU)
    * The host needs its own Mailbox (lsio_mu1 by default) and SCU
    * The original interrupt can be left here as reference but that is updated at the end of config
    */
    lsio_mu2: mailbox@5d1d0000 {
		compatible = &quot;fsl,imx8-mu-scu&quot;, &quot;fsl,imx8qm-mu&quot;, &quot;fsl,imx6sx-mu&quot;;
		reg = &lt;0x00 0x5d1d0000 0x00 0x10000&gt;;
        interrupts = &lt;GIC_SPI 178 IRQ_TYPE_LEVEL_HIGH&gt;;
		#mbox-cells = &lt;0x02&gt;;
		status = &quot;okay&quot;;
	};
};
</code></pre>
<p>The actual devices which were passed through may have some dependencies such as clocks which also need to be configured in guest for the main devices to work properly. In most cases they can be just copy pasted from the original host configuration with a few minor alterations. Which dependencies are required requires a bit of manual labor and depends on case to case. The main key is to go through the whole original device tree and list out device node names that are used by the passed through devices. This may require several passes as the dependencies may also contain some dependencies of their own. On top of the reuirements it is good also to check if the passed through devices are used by some other devies. Some devices may be used through a controller such as in our case <strong>lsio_mu2</strong> is used by the main system control unit <strong>scu</strong>. In this case the dependencies consist of several clock devices and their controller and also the imx8 system control unit <strong>SCU</strong> device with its internals.</p>
<p>In this case the assisting devices can be added just before the start &quot;<strong>platform@c000000</strong>&quot; bus configuration section. </p>
<pre><code>/**
 * Several clocks and a regulator copied from original host config.
 **/
clk_dummy: clock-dummy {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;0&gt;;
	clock-output-names = &quot;clk_dummy&quot;;
};

xtal32k: clock-xtal32k {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;32768&gt;;
	clock-output-names = &quot;xtal_32KHz&quot;;
};

xtal24m: clock-xtal24m {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;24000000&gt;;
	clock-output-names = &quot;xtal_24MHz&quot;;
};

reg_fec2_supply: fec2_nvcc {
	compatible = &quot;regulator-fixed&quot;;
	regulator-name = &quot;fec2_nvcc&quot;;
	regulator-min-microvolt = &lt;1800000&gt;;
	regulator-max-microvolt = &lt;1800000&gt;;
//	gpio = &lt;&amp;max7322 0 GPIO_ACTIVE_HIGH&gt;;
	enable-active-high;
	status = &quot;okay&quot;;
};

conn_axi_clk: clock-conn-axi {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;333333333&gt;;
	clock-output-names = &quot;conn_axi_clk&quot;;
};

conn_ahb_clk: clock-conn-ahb {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;166666666&gt;;
	clock-output-names = &quot;conn_ahb_clk&quot;;
};

conn_ipg_clk: clock-conn-ipg {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;83333333&gt;;
	clock-output-names = &quot;conn_ipg_clk&quot;;
};

conn_bch_clk: clock-conn-bch {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;400000000&gt;;
	clock-output-names = &quot;conn_bch_clk&quot;;
};

/**
 * imx8 SCU device and its content with changed to use &quot;lsio_mu2&quot; mailbox
 * The original scu used lsio_mu1 so we need to use one of lsio_mu2 to lsio_mu4
 **/
scu {
	compatible = &quot;fsl,imx-scu&quot;;
	mbox-names = &quot;tx0&quot;, &quot;rx0&quot;, &quot;gip3&quot;;
	mboxes = &lt;&amp;lsio_mu2 0 0
		&amp;lsio_mu2 1 0
		&amp;lsio_mu2 3 3&gt;;

	pd: imx8qx-pd {
		compatible = &quot;fsl,imx8qm-scu-pd&quot;, &quot;fsl,scu-pd&quot;;
		#power-domain-cells = &lt;1&gt;;
		status = &quot;okay&quot;;

		wakeup-irq = &lt;235 236 237 258 262 267 271
				345 346 347 348&gt;;
	};

	clk: clock-controller {
		compatible = &quot;fsl,imx8qm-clk&quot;, &quot;fsl,scu-clk&quot;;
		#clock-cells = &lt;2&gt;;
		clocks = &lt;&amp;xtal32k &amp;xtal24m&gt;;
		clock-names = &quot;xtal_32KHz&quot;, &quot;xtal_24Mhz&quot;;
	};

	iomuxc: pinctrl {
		compatible = &quot;fsl,imx8qm-iomuxc&quot;;
	};

	ocotp: imx8qm-ocotp {
		compatible = &quot;fsl,imx8qm-scu-ocotp&quot;;
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;1&gt;;
		read-only;

		fec_mac0: mac@1c4 {
			reg = &lt;0x1c4 6&gt;;
		};

		fec_mac1: mac@1c6 {
			reg = &lt;0x1c6 6&gt;;
		};
	};

	rtc: rtc {
		compatible = &quot;fsl,imx8qm-sc-rtc&quot;;
	};

	watchdog {
		compatible = &quot;fsl,imx8qm-sc-wdt&quot;, &quot;fsl,imx-sc-wdt&quot;;
		timeout-sec = &lt;60&gt;;
	};

	tsens: thermal-sensor {
		compatible = &quot;fsl,imx-sc-thermal&quot;;
		tsens-num = &lt;6&gt;;
		#thermal-sensor-cells = &lt;1&gt;;
	};
};

/**
 * And the platform bus that was done earlier would start from here..
 */
platform@c000000 {
    ...
};
</code></pre>
<h3 id="some-final-touches-for-guest-devices"><a class="header" href="#some-final-touches-for-guest-devices">Some Final Touches for Guest Devices</a></h3>
<p>Now we have most of the actual devices setup. Some final modifications for individual devices can be done at the end of the guest devicetree config. These can be done outside the main node as we just modify some node properties which are already defined.</p>
<pre><code>/**
 * For fec1 we need to update the interrupts to match the ones used by guest pass-through.
 * Most of the configuration is exactly the same that was set original imx8 config
 * Qemu starts its pass-through interrupts at 0x70 so lets change that
 * It is not strictly required to remove the possible iommus property but lets do that anyway
 */
&amp;fec1 {
    compatible = &quot;fsl,imx8qm-fec&quot;, &quot;fsl,imx6sx-fec&quot;;
    interrupts = &lt;GIC_SPI 0x70 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x71 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x72 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x73 IRQ_TYPE_LEVEL_HIGH&gt;;
    /delete-property/ iommus;
    pinctrl-names = &quot;default&quot;;
    pinctrl-0 = &lt;&amp;pinctrl_fec1&gt;;
    phy-mode = &quot;rgmii-txid&quot;;
    phy-handle = &lt;&amp;ethphy0&gt;;
    fsl,magic-packet;
    nvmem-cells = &lt;&amp;fec_mac0&gt;;
    nvmem-cell-names = &quot;mac-address&quot;;
    status = &quot;okay&quot;;

    mdio {
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;

        ethphy0: ethernet-phy@0 {
            compatible = &quot;ethernet-phy-ieee802.3-c22&quot;;
            reg = &lt;0&gt;;
            at803x,eee-disabled;
            at803x,vddio-1p8v;
            qca,disable-smarteee;
            vddio-supply = &lt;&amp;vddio0&gt;;

            vddio0: vddio-regulator {
                regulator-min-microvolt = &lt;1800000&gt;;
                regulator-max-microvolt = &lt;1800000&gt;;
            };
        };
    };
};

/**
 * Not much to do for clock controller
 * Remove the iommus as it is not needed in guest and turn the device on
 */
&amp;enet0_lpcg {
    status = &quot;okay&quot;;
    /delete-property/ iommus;
};

/**
 * Same for our mailbox
 * Update the interrupts to match next available interrupt in Qemu
 */
&amp;lsio_mu2 {
    compatible = &quot;fsl,imx8-mu-scu&quot;, &quot;fsl,imx8qm-mu&quot;, &quot;fsl,imx6sx-mu&quot;;
    interrupts = &lt;GIC_SPI 0x74 IRQ_TYPE_LEVEL_HIGH&gt;;
    /delete-property/ iommus;
    status = &quot;okay&quot;;
};

/**
 * In the host devicetree we had some pads which were transferred to guest.
 * There can be found in the original imx8 hosts config.
 **/
&amp;iomuxc {
    pinctrl-names = &quot;default&quot;;
    status = &quot;okay&quot;;

    pinctrl_fec1: fec1grp {
        fsl,pins = &lt;
            IMX8QM_COMP_CTL_GPIO_1V8_3V3_ENET_ENETA_PAD		0x000014a0
            IMX8QM_ENET0_MDC_CONN_ENET0_MDC				0x06000020
            IMX8QM_ENET0_MDIO_CONN_ENET0_MDIO			0x06000020
            IMX8QM_ENET0_RGMII_TX_CTL_CONN_ENET0_RGMII_TX_CTL	0x06000020
            IMX8QM_ENET0_RGMII_TXC_CONN_ENET0_RGMII_TXC		0x06000020
            IMX8QM_ENET0_RGMII_TXD0_CONN_ENET0_RGMII_TXD0		0x06000020
            IMX8QM_ENET0_RGMII_TXD1_CONN_ENET0_RGMII_TXD1		0x06000020
            IMX8QM_ENET0_RGMII_TXD2_CONN_ENET0_RGMII_TXD2		0x06000020
            IMX8QM_ENET0_RGMII_TXD3_CONN_ENET0_RGMII_TXD3		0x06000020
            IMX8QM_ENET0_RGMII_RXC_CONN_ENET0_RGMII_RXC		0x06000020
            IMX8QM_ENET0_RGMII_RX_CTL_CONN_ENET0_RGMII_RX_CTL	0x06000020
            IMX8QM_ENET0_RGMII_RXD0_CONN_ENET0_RGMII_RXD0		0x06000020
            IMX8QM_ENET0_RGMII_RXD1_CONN_ENET0_RGMII_RXD1		0x06000020
            IMX8QM_ENET0_RGMII_RXD2_CONN_ENET0_RGMII_RXD2		0x06000020
            IMX8QM_ENET0_RGMII_RXD3_CONN_ENET0_RGMII_RXD3		0x06000020
        &gt;;
    };
};
</code></pre>
<p>With our additional devices also some headers and definitions need to be included in the beginning of the device tree. These additions can be found also from the original imx8 device tree files. See the full device tree below for reference.</p>
<h2 id="compiling-the-device-tree-source-to-binary-form"><a class="header" href="#compiling-the-device-tree-source-to-binary-form">Compiling the Device Tree Source to Binary Form</a></h2>
<p>The device trees need to be compiled within linux kernel source directory. They depend on some kernel device tree headers and in host device case of other device tree source files. </p>
<ul>
<li>Full host device tree: <a href="research/pass-through/imx8qm-mek_conn-host.dts">imx8qm-mek_conn-host.dts</a></li>
<li>Full guest device tree: <a href="research/pass-through/imx8qm-mek_conn-guest.dts">imx8qm-mek_conn-guest.dts</a></li>
</ul>
<h3 id="compiling-for-guest"><a class="header" href="#compiling-for-guest">Compiling for Guest</a></h3>
<pre><code>cpp -nostdinc -I include -I arch  -undef -x assembler-with-cpp \
    arch/arm64/boot/dts/freescale/imx8qm-mek_conn-guest.dts imx8qm-mek_conn-guest.dts.preprocessed; \
    dtc -I dts -O dtb -p 0x1000 imx8qm-mek_conn-guest.preprocessed -o imx8qm-mek_conn-guest.dtb
</code></pre>
<h3 id="compiling-for-host"><a class="header" href="#compiling-for-host">Compiling for Host</a></h3>
<pre><code>cpp -nostdinc -I include -I arch  -undef -x assembler-with-cpp \
    arch/arm64/boot/dts/freescale/imx8qm-mek_conn-host.dts imx8qm-mek_conn-host.dts.preprocessed; \
    dtc -I dts -O dtb -p 0x1000 imx8qm-mek_conn-host.preprocessed -o imx8qm-mek_conn-host.dtb
</code></pre>
<h2 id="running-qemu-with-pass-through-platform-devices"><a class="header" href="#running-qemu-with-pass-through-platform-devices">Running QEMU with Pass-through Platform Devices</a></h2>
<p>To get pass-through working i.MX 8QM needs to be booted using our freshly built hosts <strong>imx8qm-mek_conn-host.dtb</strong> device tree file.</p>
<p>When the system has booted we need to set up the passed-through devices for VFIO driver and start QEMU with devices passed through.</p>
<p>First, the devices need to be setup for VFIO:</p>
<pre><code>echo vfio-platform  &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver_override
echo 5d1d0000.mailbox &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b040000.ethernet/driver_override
echo 5b040000.ethernet &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver_override
echo 5b230000.clock-controller &gt; /sys/bus/platform/drivers/vfio-platform/bind
</code></pre>
<p>After that QEMU can be started with our devices over the devices.</p>
<p>This is just as an example and may require a bit of change in other environments.</p>
<p>In this example, the guest kernel image, ext2 rootfs and guest device tree — all use the same filename prefix <strong>imx8qm-mek_conn-guest</strong>.</p>
<pre><code>qemu-system-aarch64 \
    -M virt,gic-version=host -enable-kvm \
    -cpu host \
    -m 512M \
    -kernel &quot;imx8qm-mek_conn-guest.Image&quot; \
    -drive file=&quot;imx8qm-mek_conn-guest.ext2&quot;,if=virtio,format=raw -dtb &quot;imx8qm-mek_conn-guest.dtb&quot; \
    -nographic \
    -append &quot;loglevel=7 rootwait root=/dev/vda console=ttyAMA0 earlycon earlyprintk&quot; \
    -device vfio-platform,host=5b230000.clock-controller \
    -device vfio-platform,host=5b040000.ethernet \
    -device vfio-platform,host=5d1d0000.mailbox
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
